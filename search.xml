<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMU 15122: Contracts</title>
    <url>/posts/cmu15122note1.html</url>
    <content><![CDATA[<p>CMU15122开头部分讲的内容都是关于如何编写Contracts来保证程序的正确性和安全性，以及利用Contract对程序进行验证。本文简单梳理其中引出的概念。</p>
<h2 id="contract">Contract</h2>
<p>c0中有四种Contract：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- //@requires exp; checked before function execution</span><br><span class="line">- //@ensures exp; checked function returns</span><br><span class="line">- //@assert exp; checked wherever it is</span><br><span class="line">- //@loop_invariant exp; checked before the loop guard</span><br></pre></td></tr></table></figure>
<p>其中@requires旨在检查函数的precondition是否满足，@ensures旨在检查postcondition是否满足。其中@ensures中可以使用\result来表示函数返回值。@loop_invariant通常检查的是循环中几个变量构成的常量表达式，其在每轮iteration检查循环条件是否满足时被检查，并且只能在循环开头写。@assert即在程序任意位置检查附上表达式的真假。</p>
<h2 id="proving-function-correctness">Proving Function Correctness</h2>
<ul>
<li>
<p>INITialization：证明loop invariant在进入循环之前满足条件。允许使用循环前的代码以及preconditions进行证明。</p>
</li>
<li>
<p>PREServation：证明任意循环后loop invariant的表达式都为真。可以使用循环内部代码，loop invariant(因为INIT已经验证了进入循环时表达式为真，因此可以假设循环开始时为真)，以及loop guard。</p>
</li>
<li>
<p>EXIT：证明经过循环postcondition为真。可以使用loop guard，loop invariant以及循环之后的代码进行证明。需要注意的是虽然可使用loop guard以及loop invariant，但无法使用循环内部代码。</p>
</li>
<li>
<p>TERMination：证明循环可终止。Operational reasoning(Expression strictly decreases at each iteration of the loop and can never become smaller than the constant)。</p>
</li>
</ul>
<h3 id="template">Template</h3>
<p>Loop invariant/… on line x (…):<br>
Assume:<br>
To show:<br>
A.       by<br>
B.       by<br>
C.       by<br>
D.       by</p>
<h2 id="point-to-reasoning">Point-to Reasoning</h2>
<p>Point-to Reasoning is drawing conclusions about what we know to be true by pointing to specific lines of code that justify them.</p>
<p>Examples:</p>
<ul>
<li>Boolean conditions
<ul>
<li>condition of an if statement in the “then” branch</li>
<li>negation of the condition of an if statement in the “else” branch</li>
<li>loop guard inside the body of a loop</li>
<li>negation of the loop guard after the loop</li>
</ul>
</li>
<li>Contract annotations
<ul>
<li>preconditions of the current function</li>
<li>postconditions of a function just called</li>
<li>loop invariant inside the loop body</li>
<li>loop invariant after the loop</li>
<li>earlier fully justified assertions</li>
</ul>
</li>
<li>Math
<ul>
<li>laws of logic</li>
<li>some laws of arithmetic</li>
</ul>
</li>
<li>Value of variables right after an assignment</li>
</ul>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU 15122：Deliberate Programming</title>
    <url>/posts/cmu15122note2.html</url>
    <content><![CDATA[<p>本篇总结CMU 15122第一单元Deliberate Programming的全部内容（除了Contracts部分）。这门课的整体脉络还是较为清晰的，虽然大部分东西并不陌生，但从safety和correctness的角度重新审视一遍也是不错的。</p>
<h1 id="integers">Integers</h1>
<p>涉及进制转换的内容略过不提。</p>
<h2 id="two-s-complement">Two’s Complement</h2>
<p>Two’s Complement是C0中表示数字的一种方法。C0中的整数一共占据32个比特位，其中最高的比特位是该比特位代表的负的2的31次方，也就是说，C0中的最大正整数可以用0x7FFFFFFF表示，正数的范围是0x00000000-0x7FFFFFFF(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mtext> </mtext><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0~2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)。当最大正整数int_max()再继续做加法的时候整数就会溢出到负数的范围内，也就是0x80000000-0xFFFFFFFF。其中0x80000000是int_min()，其顺序与正数表示相反。由此，c0能够表示的整个整数范围是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[-2^{31}, 2^{31})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>对于int的操作类型有：Addition, multiplication, division, subtraction, comparisons, mod;</p>
<p>对于Tow’s complement表示方法来说，有以下成立：</p>
<ul>
<li>-x = ~x + 1</li>
<li>int_min() = -int_min()</li>
</ul>
<p>对于以下操作会产生runtime error：</p>
<ul>
<li>int_min() (/ or %) - 1</li>
<li>x / 0</li>
</ul>
<h2 id="bit-pattern">Bit Pattern</h2>
<p>Int不是数字，是0和1组成的字符串。因此，bitwise operation可以通过对每一比特位进行操作来改变数字大小。其中包括是掩码以及各种比特位操作。&amp; 0xFF000000 可以将另外一个32位数的后24位全部置为零，这就是为什么其被称作mask（掩码）。另外我们可以通过| 0xFF000000 将32位数的前8位全部置为1。左移&lt;&lt;就是将比特数左移多少位，右边补零。右移&gt;&gt;会根据最高位进行补齐。</p>
<h1 id="arrays">Arrays</h1>
<p>数组是相同类型数据的集合，例如 int[] 表示整型数组。数组可以包含任何类型的元素，包括其他数组。</p>
<p>局部变量存储在局部内存中，函数的变量在各自的帧（frame）中。函数调用时，每个被调用的函数都有自己的帧，且只能操作自己帧中的变量。函数返回后，其帧被撤销。</p>
<p>使用 alloc_array(type, n) 创建数组，返回一个类型为 type[] 的数组，包含 n 个元素。数组的元素存储在分配的内存中，而数组变量本身存储在局部内存中，包含指向分配内存的地址。通过 A[i] 访问数组 A 的第 i 个元素，索引从0开始。分配的内存使用默认值初始化，对于整型数组，默认值为0。越界访问（out-of-bound access）是不允许的，有效索引是0到数组长度减一。数组操作需要满足前提条件（preconditions），例如 alloc_array(type, n) 需要 n ≥ 0。</p>
<p>C0中Aarray变量名存储的是数列的地址，因此，假如int[] B = A，A是某个已经存在的数列，B只会复制A的地址。后续对B的操作也实际上是对于A的操作。一旦某个数列没有指针指向它，C0的Garbage Collector就会消除掉该数列。整数与整数之间不涉及到地址的问题。C0无法返回某个数组的长度，但是用Contract中的\length()可以。</p>
<h1 id="searching-and-sorting">Searching and Sorting</h1>
<p>In-place: allocates constant amount of memory.<br>
Stable: relative position of duplicates is preserved.</p>
<h2 id="linear-search">Linear Search</h2>
<p>Linear Search本身没什么可以探讨的，主要是关于contracts方面的问题。</p>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool is_in(int x, int[] A, int lo, int hi)</span><br><span class="line">//@requires 0 &lt;= lo &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= \length(A);</span><br><span class="line">//Check whether x is in array segment A, [lo, hi)</span><br><span class="line"></span><br><span class="line">int linearSearch(int x, int[] A, int n)</span><br><span class="line">//@requires n == \length(A);</span><br><span class="line">/*@ensures (-1 == \result &amp;&amp; !is_in(x, A, 0, n)) ||</span><br><span class="line">           ((0 &lt;= \result &amp;&amp; \result &lt; n) &amp;&amp; A[\result] == x);</span><br><span class="line">&#123;</span><br><span class="line">  for (int i = 0; i &lt; n; i++)</span><br><span class="line">  //@loop_invariant 0 &lt;= i &amp;&amp; i &lt;= n;</span><br><span class="line">  //@loop_invariant !is_in(x, A, 0, n);</span><br><span class="line">  &#123;</span><br><span class="line">    if (A[i] == x) return i;</span><br><span class="line">  &#125;</span><br><span class="line">  //@assert !is_in(x, A, 0, n);</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="safety-and-correctness">Safety and Correctness</h3>
<p>确保搜索过程中数组索引 i 在有效范围内，即 0 &lt;= i &lt; n，其中 n 是数组 A 的长度。使用contract来定义函数的前提条件（@requires）和后置条件（@ensures）。前提条件：确保传入的数组长度 n 与数组 A 的实际长度相匹配。后置条件：如果找到元素 x，则返回其索引；否则返回 -1。</p>
<ul>
<li>数组段表示数组中的一部分，用 A[lo, hi) 表示，包含从索引 lo（包含）到索引 hi（不包含）的元素。</li>
<li>定义 is_in(x, A, lo, hi) 函数，用于检查元素 x 是否在数组段 A[lo, hi) 中。</li>
</ul>
<h3 id="contract-exploits">Contract Exploits</h3>
<p>即使函数满足Contract，也可能不满足预期的行为。例如，一个函数可以满足Contract但在逻辑上是错误的。</p>
<h2 id="binary-search">Binary Search</h2>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binarySearch(int x, int[] A, int n)</span><br><span class="line">//@requires n == \length(A);</span><br><span class="line">//@requires is_sorted(A,0,n);</span><br><span class="line">/*@ensures (-1 == \result &amp;&amp; !is_in(x, A,0,n))</span><br><span class="line">        || ((0 &lt;= \result &amp;&amp; \result &lt; n) &amp;&amp; A[\result] == x);</span><br><span class="line">  @*/</span><br><span class="line">&#123;</span><br><span class="line">  for (int i = 0; i &lt; n; i++)</span><br><span class="line">  //@loop_invariant 0 &lt;= i &amp;&amp; i &lt;= n;</span><br><span class="line">  //@loop_invariant gt_seg(x, A,0,i);       // implies !is_in(x, A,0,i)</span><br><span class="line">  //@loop_invariant !is_in(x, A,0,i);</span><br><span class="line">  //@loop_invariant le_segs(A,0,i, A,i,n);  // because is_sorted(A,0,n)</span><br><span class="line">  &#123;</span><br><span class="line">    if (A[i] == x) return i;</span><br><span class="line">    if (A[i] &gt; x) &#123;</span><br><span class="line">      //@assert lt_seg(x, A,i,n);           // implies !is_in(x, A,i,n)</span><br><span class="line">      //@assert !is_in(x, A,i,n);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //@assert A[i] &lt; x;                     // implies gt_seg(x, A,0,i+1);</span><br><span class="line">    //@assert gt_seg(x, A,0,i+1);</span><br><span class="line">  &#125;</span><br><span class="line">  //@assert !is_in(x, A,0,n);</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用循环，维护两个指针lo（low）和hi（high），分别代表搜索区间的下限和上限。<br>
计算中间索引mid，并与目标值x进行比较。</p>
<ul>
<li>如果A[mid]等于x，则返回mid。</li>
<li>如果x小于A[mid]，则更新hi为mid。</li>
<li>如果x大于A[mid]，则更新lo为mid + 1。</li>
</ul>
<p>当lo和hi相遇时，搜索结束，返回-1表示未找到。</p>
<h3 id="loop-invariant">Loop Invariant</h3>
<ul>
<li>0 ≤ lo</li>
<li>lo ≤ hi</li>
<li>hi ≤ n</li>
<li>A[0, lo) &lt; x</li>
<li>x &lt; A[hi, n)</li>
</ul>
<p>应确保mid的计算不会超出整数范围，避免溢出错误。循环不变式在算法的初始化（INIT）、保持（PRES）和终止（TERMINATE）阶段都是可以被证明有效的。</p>
<h2 id="mergesort">Mergesort</h2>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(int[] A, int lo, int mid, int hi)</span><br><span class="line">//@requires 0 &lt;= lo &amp;&amp; lo &lt;= mid &amp;&amp; mid &lt;= hi &amp;&amp; hi &lt;= \length(A);</span><br><span class="line">//@requires is_sorted(A, lo, mid) &amp;&amp; is_sorted(A, mid, hi);</span><br><span class="line">//@ensures is_sorted(A, lo, hi);</span><br><span class="line">&#123;</span><br><span class="line">  int[] B = alloc_array(int, hi-lo);</span><br><span class="line">  int i = lo;</span><br><span class="line">  int j = mid;</span><br><span class="line">  int k = 0;</span><br><span class="line"></span><br><span class="line">  while (i &lt; mid &amp;&amp; j &lt; hi)</span><br><span class="line">  //@loop_invariant lo &lt;= i &amp;&amp; i &lt;= mid;</span><br><span class="line">  //@loop_invariant mid &lt;= j &amp;&amp; j &lt;= hi;</span><br><span class="line">  //@loop_invariant k == (i - lo) + (j - mid);</span><br><span class="line">  &#123;</span><br><span class="line">    if (A[i] &lt;= A[j]) &#123;</span><br><span class="line">      B[k] = A[i];</span><br><span class="line">      i++;</span><br><span class="line">    &#125; else &#123; //@assert A[i] &gt; A[j];</span><br><span class="line">      B[k] = A[j];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //@assert i == mid || j == hi;</span><br><span class="line">  // Exercise: write the omitted invariants for these loops</span><br><span class="line">  while (i &lt; mid) &#123; B[k] = A[i]; i++; k++; &#125;</span><br><span class="line">  while (j &lt; hi)  &#123; B[k] = A[j]; j++; k++; &#125;</span><br><span class="line"></span><br><span class="line">  // Copy sorted array back into A</span><br><span class="line">  for (k = 0; k &lt; hi-lo; k++)</span><br><span class="line">    A[lo+k] = B[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// mergesort</span><br><span class="line">void sort(int[] A, int lo, int hi)</span><br><span class="line">//@requires 0 &lt;= lo &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= \length(A);</span><br><span class="line">//@ensures is_sorted(A, lo, hi);</span><br><span class="line">&#123;</span><br><span class="line">  if (hi - lo &lt;= 1)            //@assert is_sorted(A, lo, hi);</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  int mid = lo + (hi - lo)/2;  //@assert lo &lt; mid &amp;&amp; mid &lt; hi;</span><br><span class="line">  sort(A, lo, mid);            //@assert is_sorted(A, lo, mid);</span><br><span class="line">  sort(A, mid, hi);            //@assert is_sorted(A, mid, hi);</span><br><span class="line">  merge(A, lo, mid, hi);       //@assert is_sorted(A, lo, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="explanation">Explanation</h3>
<ol>
<li>递归地将数组分成两半，直到分出的数组长度为1或者为0;</li>
<li>递归地将数组两两合并，合并的时候做具体的比较运算使得合并出来的数组都是有序的;</li>
<li>Merge Halves -&gt; O(n) cost.</li>
<li>Levels of Merging -&gt; O(logn) cost.</li>
<li>O(nlogn) cost.</li>
</ol>
<h2 id="quicksort">Quicksort</h2>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int partition(int[] A, int lo, int hi)</span><br><span class="line">//@requires 0 &lt;= lo &amp;&amp; lo &lt; hi &amp;&amp; hi &lt;= \length(A);</span><br><span class="line">//@ensures lo &lt;= \result &amp;&amp; \result &lt; hi;</span><br><span class="line">//@ensures ge_seg(A[\result], A, lo, \result);</span><br><span class="line">//@ensures le_seg(A[\result], A, \result+1, hi);</span><br><span class="line">&#123;</span><br><span class="line">  int pi = lo + (hi - lo)/2;</span><br><span class="line">  int pivot = A[pi];</span><br><span class="line">  swap(A, pi, lo);</span><br><span class="line">  int left = lo + 1;</span><br><span class="line">  int right = hi;</span><br><span class="line"></span><br><span class="line">  while (left &lt; right)</span><br><span class="line">  //@loop_invariant lo+1 &lt;= left &amp;&amp; left &lt;= right &amp;&amp; right &lt;= hi;</span><br><span class="line">  //@loop_invariant ge_seg(pivot, A, lo, left);</span><br><span class="line">  //@loop_invariant le_seg(pivot, A, right, hi);</span><br><span class="line">  //@loop_invariant pivot == A[lo];</span><br><span class="line">  &#123;</span><br><span class="line">    if (A[left] &lt;= pivot) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //@assert A[left] &gt; pivot;</span><br><span class="line">      swap(A, left, right-1);</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //@assert left == right;</span><br><span class="line">  swap(A, lo, left-1);</span><br><span class="line">  return left-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// quicksort</span><br><span class="line">void sort(int[] A, int lo, int hi)</span><br><span class="line">//@requires 0 &lt;= lo &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= \length(A);</span><br><span class="line">//@ensures is_sorted(A, lo, hi);</span><br><span class="line">&#123;</span><br><span class="line">  if (hi - lo &lt;= 1)               //@assert is_sorted(A, lo, hi);</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  int p = partition(A, lo, hi);   //@assert lo &lt;= p &amp;&amp; p &lt; hi;</span><br><span class="line">  //@assert ge_seg(A[p], A,lo,p) &amp;&amp; le_seg(A[p], A,p+1,hi);</span><br><span class="line">  sort(A, lo, p);                 //@assert is_sorted(A, lo, p);</span><br><span class="line">  sort(A, p+1, hi);               //@assert is_sorted(A, p+1, hi);</span><br><span class="line">  //@assert is_sorted(A, lo, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="explanation">Explanation</h3>
<ol>
<li>随机挑一个轴;</li>
<li>遍历整个数组，把每个数和轴比较，然后放到轴的左右边;</li>
<li>递归地向下分，分到长度为1或者0时表示整个数组排序完毕;</li>
<li>Quicksort 和 Mergesort本质上很像，只不过一个在分的过程中做比较运算，一个是分完之后在合并的过程中做比较运算。</li>
<li>Unlucky: Pick smallest element as pivot O(n^2), just selection sort;</li>
<li>Average: Pick middle element -&gt; O(nlogn);</li>
</ol>
<h1 id="complexity">Complexity</h1>
<p>O(g(n))是一组函数，其中f(n)∈O(g(n))。当且仅当：</p>
<ul>
<li>有c∈R+</li>
<li>有n0∈N<br>
使对于所有n≥n0，f(n)≤cg(n)。</li>
</ul>
<p>O(1) ⊂ O(log n) ⊂ O(n) ⊂ O(n log n) ⊂ O(n2) ⊂ O(2n) ⊂ O(n!)</p>
<p>做复杂度分析是可以直接抛掉常数，取变量最坏的情况。保留不同变量间的运算。log的底因为可以通过换底公式换成常数乘以以某数为底因此不重要。</p>
<p>Linear search: O(1) best case, O(n) worst case.<br>
Binary search: O(1) best case, O(logn) worst case.<br>
Selection sort: O(n^2)<br>
Merge sort: O(nlogn)<br>
Quick sort: O(nlogn) best case, O(nlogn) avg case, O(n^2) worst case.</p>
<h1 id="structs-and-pointers">Structs and pointers</h1>
<h2 id="local-memory-and-allocated-memory">Local Memory and Allocated Memory</h2>
<ul>
<li>Local memory: Literals (int, bool, string, any direct value);
<ul>
<li>Born when: declared in its scope</li>
<li>Vanishes when: exit its scope</li>
</ul>
</li>
<li>Allocated memory: (contents of) pointers, arrays, tructs;
<ul>
<li>Born when: we allocate them;</li>
<li>Vanishes when: we can no longer access them -&gt; garbage collector;</li>
</ul>
</li>
</ul>
<h2 id="pointers">Pointers</h2>
<p>多重指针，指针修改，内存图绘制，不做赘述</p>
<p>Default values:</p>
<ul>
<li>int: 0</li>
<li>char: ‘\0’</li>
<li>string: “”</li>
<li>bool: false</li>
<li>pointer: NULL</li>
<li>array: empty array</li>
</ul>
<h2 id="structs">Structs</h2>
<p>统一管理多种类数据的方便手段。内存图绘制同样不做赘述。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct goose_header&#123;</span><br><span class="line">  string name;</span><br><span class="line">  string bowtie_color;</span><br><span class="line">  image* img;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct goose_header* silly = alloc(struct goose_header); //Using pointer to access struct fields</span><br><span class="line">typedef struct goose_header goose;</span><br><span class="line">goose* silly = alloc(goose);</span><br><span class="line"></span><br><span class="line">(*silly).bowtie_color = &quot;pink&quot;;</span><br><span class="line">//Otherwise, also recommended</span><br><span class="line">silly-&gt;bowtie_color = &quot;pink&quot;;</span><br><span class="line"></span><br><span class="line">//valid data structure</span><br><span class="line"></span><br><span class="line">bool is_goose(goose* g)&#123;</span><br><span class="line">  return g != NULL &amp;&amp; g-&gt;img != NULL;</span><br><span class="line">&#125;</span><br><span class="line">//specification function used to check if goose valid</span><br><span class="line"></span><br><span class="line">//safe pointer accesses:</span><br><span class="line">//requires g != NULL</span><br><span class="line">//requires is_goose(g), valid goose input</span><br><span class="line">//ensures is_goose(g), our function doesn&#x27;t make the goose invalid</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="interfaces-vs-implementation">Interfaces vs. Implementation</h1>
<p>我们可以通过typedef给数据起别名，这样可以增加程序的抽象程度，方便调用。调用interface进行开发的方面也不需要深入程序细节，使用提供的函数接口和数据别名就可以完成开发。因此通常情况下client使用的只是interface提供的指针，不对具体数据进行操作。specification function属于implementation contracts部分，确保程序正确性，因此client不会调用它们。因为client知道他们调用的是指针，因此为了防止指针被设置成NULL，interface中都会有NULL check，作为另一种监督程序正确性的手段。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU 15122：Data Structures</title>
    <url>/posts/cmu15122note3.html</url>
    <content><![CDATA[<h1 id="libraries">Libraries</h1>
<h2 id="overview">Overview</h2>
<p>通过使用库（libraries），程序可以复用已经编写好的代码，包括系统代码、过去编写的简单代码以及他人编写的复杂代码。库有助于隐藏不必要的细节，使代码更易于管理，并允许透明的改进。</p>
<p>Structure of a library:</p>
<ul>
<li>接口（Interface）：列出了库导出的功能及其使用方法。</li>
<li>实现（Implementation）：实现接口中列出的功能的代码。</li>
<li>文档（Documentation）：解释库中功能的作用。</li>
</ul>
<p>在编写应用程序代码时，开发者能且只能使用接口中列出的功能，不依赖于实现。编译应用程序时，需要包含库的实现。库包含系统库作为编程语言的一部分，如C0的输入输出函数，和用户定义库**：由用户编写或从互联网下载，必须与应用程序一起编译。</p>
<p>就15122而言，库最重要的帮助是定义了新数据类型及其使用方法。通过接口定义类型和操作，使得实现可以透明地更改，而不影响使用该类型的应用程序。</p>
<h2 id="example-of-self-sorting-arrays-ssa">Example of Self-Sorting Arrays, SSA</h2>
<p>SSA是一个示例数据结构，类似于字符串数组，但具有报告长度的功能，并保证其元素是排序的。</p>
<ul>
<li><strong>接口内容</strong>：
<ol>
<li>自排序数组的类型（ssa_t），通常（xxx_t）是声明struct xxx后typedef该struct的指针。</li>
<li>操作SSA的库提供的函数，如创建新数组（“ssa_new”）、读取数组索引的值（“ssa_get”）、替换数组索引的值（“ssa_set”）、返回数组长度（“ssa_len”）。</li>
<li>每个操作的contracts，包括pre/postconditions。</li>
<li>Data structure invariant, 用于确保SSA的表示是有效的，如<code>is_ssa</code>函数，只在library implementation中使用，通常用在contract的pre/postcondition当中。</li>
</ol>
</li>
</ul>
<p>客户端代码只能通过接口与SSA交互，实现细节不对客户端透明。</p>
<h1 id="stack-and-queue">Stack and Queue</h1>
<h2 id="worklists">Worklists</h2>
<ul>
<li><strong>Worklists</strong>是一个数据结构家族，可以存储元素，并提供一种方法来检索它们。客户端可以添加元素到工作列表并从中检索元素，而不需要关心其实现方式。</li>
<li><strong>例子</strong>：待办事项列表、食堂排队、操作系统中的挂起进程，栈（Stacks），队列（Queues），优先队列（Priority Queues）。</li>
<li><strong>类型</strong>：
<ul>
<li>工作列表中的元素：字符串（string）</li>
<li>工作列表本身：类型为 <code>wl_t</code></li>
</ul>
</li>
<li><strong>操作</strong>：
<ul>
<li>添加元素：<code>wl_add</code></li>
<li>检索元素：<code>wl_retrieve</code></li>
<li>创建新的工作列表：<code>wl_new</code></li>
<li>检查工作列表是否为空：<code>wl_empty</code></li>
</ul>
</li>
</ul>
<h2 id="stacks">Stacks</h2>
<ul>
<li><strong>栈</strong>是一种工作列表，其中检索的是最后插入的元素。</li>
<li><strong>操作</strong>：
<ul>
<li>压栈（push）：在栈顶添加元素</li>
<li>出栈（pop）：从栈顶移除元素</li>
</ul>
</li>
</ul>
<h3 id="the-stack-interface">The Stack Interface</h3>
<ul>
<li><strong>栈接口</strong>：工作列表接口的名称变更版，并提供复杂度界限。</li>
<li><strong>操作</strong>：
<ul>
<li><code>stack_empty(stack_t S)</code>：检查栈是否为空，时间复杂度 O(1)</li>
<li><code>stack_new()</code>：创建一个新的空栈，时间复杂度 O(1)</li>
<li><code>push(stack_t S, string x)</code>：向栈中添加元素，时间复杂度 O(1)</li>
<li><code>pop(stack_t S)</code>：从栈中移除元素，时间复杂度 O(1)</li>
</ul>
</li>
</ul>
<h3 id="peeking-into-a-stack">Peeking into a Stack</h3>
<ul>
<li><strong>查看栈顶元素</strong>：编写一个客户端函数，返回栈顶元素但不移除它。</li>
<li><strong>实现</strong>：使用 <code>pop</code> 操作移除栈顶元素，然后使用 <code>push</code> 操作将其放回。</li>
</ul>
<h3 id="the-size-of-a-stack">The Size of a Stack</h3>
<ul>
<li><strong>栈的大小</strong>：编写一个客户端函数，返回栈中元素的数量。</li>
<li><strong>实现</strong>：通过 <code>pop</code> 操作计数元素，然后将它们压回栈中以恢复原始顺序。</li>
</ul>
<h3 id="sample-implementation">Sample implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#use &lt;conio&gt;</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">/* Aux structure of linked lists */</span><br><span class="line">typedef struct list_node list;</span><br><span class="line">struct list_node &#123;</span><br><span class="line">  string data;</span><br><span class="line">  list* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_acyclic(list* start) &#123;</span><br><span class="line">  if (start == NULL) return true;</span><br><span class="line">  list* h = start-&gt;next;         // hare</span><br><span class="line">  list* t = start;               // tortoise</span><br><span class="line">  while (h != t) &#123;</span><br><span class="line">    if (h == NULL || h-&gt;next == NULL) return true;</span><br><span class="line">    h = h-&gt;next-&gt;next;</span><br><span class="line">    //@assert t != NULL; // hare is faster and hits NULL quicker</span><br><span class="line">    t = t-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  //@assert h == t;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* is_segment(start, end) will diverge if list is circular! */</span><br><span class="line">bool is_segment(list* start, list* end) &#123;</span><br><span class="line">  if (start == NULL) return false;</span><br><span class="line">  if (start == end) return true;</span><br><span class="line">  return is_segment(start-&gt;next, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Will run for ever if the segment is circular</span><br><span class="line">void print_segment(list* start, list* end)</span><br><span class="line">//requires start != NULL;</span><br><span class="line">&#123;</span><br><span class="line">  for (list* p = start; p != end; p = p-&gt;next) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, p-&gt;data);</span><br><span class="line">    if (p != end) printf(&quot;-&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Stacks */</span><br><span class="line"></span><br><span class="line">typedef struct stack_header stack;</span><br><span class="line">struct stack_header &#123;</span><br><span class="line">  list* top;</span><br><span class="line">  list* floor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void stack_print_unsafe(stack* S)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;[top] &quot;);</span><br><span class="line">  print_segment(S-&gt;top, S-&gt;floor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_stack(stack* S) &#123;</span><br><span class="line">  return S != NULL</span><br><span class="line">      &amp;&amp; is_acyclic(S-&gt;top)</span><br><span class="line">      &amp;&amp; is_segment(S-&gt;top, S-&gt;floor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stack_print_internal(stack* S)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">&#123;</span><br><span class="line">  stack_print_unsafe(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool stack_empty(stack* S)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">&#123;</span><br><span class="line">  return S-&gt;top == S-&gt;floor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack* stack_new()</span><br><span class="line">//@ensures is_stack(\result);</span><br><span class="line">//@ensures stack_empty(\result);</span><br><span class="line">&#123;</span><br><span class="line">  stack* S = alloc(stack);</span><br><span class="line">  list* l = alloc(list);</span><br><span class="line">  S-&gt;top = l;</span><br><span class="line">  S-&gt;floor = l;</span><br><span class="line">  return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(stack* S, string x)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">//@ensures is_stack(S);</span><br><span class="line">//@ensures !stack_empty(S);</span><br><span class="line">&#123;</span><br><span class="line">  list* l = alloc(list);</span><br><span class="line">  l-&gt;data = x;</span><br><span class="line">  l-&gt;next = S-&gt;top;</span><br><span class="line">  S-&gt;top = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string pop(stack* S)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">//@requires !stack_empty(S);</span><br><span class="line">//@ensures is_stack(S);</span><br><span class="line">&#123;</span><br><span class="line">  string e = S-&gt;top-&gt;data;</span><br><span class="line">  S-&gt;top = S-&gt;top-&gt;next;</span><br><span class="line">  return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stack_print(stack* S)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;TOP: &quot;);</span><br><span class="line">  for (list* l = S-&gt;top; l != S-&gt;floor; l = l-&gt;next) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, l-&gt;data);</span><br><span class="line">    if (l-&gt;next != S-&gt;floor) printf(&quot; | &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client type</span><br><span class="line">typedef stack* stack_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/******************************* Interface ******************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* stack_t;</span><br><span class="line"></span><br><span class="line">bool stack_empty(stack_t S)       /* O(1) */</span><br><span class="line">/*@requires S != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">stack_t stack_new()               /* O(1) */</span><br><span class="line">/*@ensures \result != NULL; @*/</span><br><span class="line">/*@ensures stack_empty(\result); @*/ ;</span><br><span class="line"></span><br><span class="line">void push(stack_t S, string x)    /* O(1) */</span><br><span class="line">/*@requires S != NULL; @*/</span><br><span class="line">/*@ensures !stack_empty(S); @*/ ;</span><br><span class="line"></span><br><span class="line">string pop(stack_t S)             /* O(1) */</span><br><span class="line">/*@requires S != NULL; @*/</span><br><span class="line">/*@requires !stack_empty(S); @*/ ;</span><br><span class="line"></span><br><span class="line">void stack_print(stack_t S)       /* O(n) */</span><br><span class="line">/*@requires S != NULL; @*/ ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="queues">Queues</h2>
<ul>
<li><strong>队列</strong>是一种工作列表，其中检索的是最早插入的元素。</li>
<li><strong>操作</strong>：
<ul>
<li><code>enqueue</code>：在队列尾部添加元素</li>
<li><code>dequeue</code>：从队列头部移除元素</li>
</ul>
</li>
</ul>
<h3 id="the-queue-interface">The Queue Interface</h3>
<ul>
<li><strong>队列接口</strong>：类似于工作列表接口，名称变更。</li>
<li><strong>操作</strong>：
<ul>
<li><code>queue_empty(queue_t S)</code>：检查队列是否为空，时间复杂度 O(1)</li>
<li><code>queue_new()</code>：创建一个新的空队列，时间复杂度 O(1)</li>
<li><code>enq(queue_t S, string x)</code>：向队列中添加元素，时间复杂度 O(1)</li>
<li><code>deq(queue_t S)</code>：从队列中移除元素，时间复杂度 O(1)</li>
</ul>
</li>
</ul>
<h3 id="copying-a-queue">Copying a Queue</h3>
<ul>
<li><strong>复制队列</strong>：编写一个客户端函数，返回队列的深拷贝，即一个新队列，包含与原队列相同顺序的元素。</li>
</ul>
<h3 id="sample-implementation">Sample implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#use &lt;conio&gt;</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">/* Aux structure of linked lists */</span><br><span class="line">typedef struct list_node list;</span><br><span class="line">struct list_node &#123;</span><br><span class="line">  string data;</span><br><span class="line">  list* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_acyclic(list* start) &#123;</span><br><span class="line">  if (start == NULL) return true;</span><br><span class="line">  list* h = start-&gt;next;         // hare</span><br><span class="line">  list* t = start;               // tortoise</span><br><span class="line">  while (h != t) &#123;</span><br><span class="line">    if (h == NULL || h-&gt;next == NULL) return true;</span><br><span class="line">    h = h-&gt;next-&gt;next;</span><br><span class="line">    //@assert t != NULL; // hare is faster and hits NULL quicker</span><br><span class="line">    t = t-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  //@assert h == t;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* is_segment(start, end) will diverge if list is circular! */</span><br><span class="line">// Recursive version</span><br><span class="line">bool is_segment(list* start, list* end) &#123;</span><br><span class="line">  if (start == NULL) return false;</span><br><span class="line">  if (start == end) return true;</span><br><span class="line">  return is_segment(start-&gt;next, end);</span><br><span class="line">&#125;</span><br><span class="line">// Iterative version using a while loop</span><br><span class="line">bool is_segmentB(list* start, list* end) &#123;</span><br><span class="line">  list* l = start;</span><br><span class="line">  while (l != NULL) &#123;</span><br><span class="line">    if (l == end) return true;</span><br><span class="line">    l = l-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">// Iterative version using a for loop</span><br><span class="line">bool is_segmentC(list* start, list* end) &#123;</span><br><span class="line">  for (list* p = start; p != NULL; p = p-&gt;next) &#123;</span><br><span class="line">    if (p == end) return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Will run for ever if the segment is circular</span><br><span class="line">void print_segment(list* start, list* end)</span><br><span class="line">//requires start != NULL;</span><br><span class="line">&#123;</span><br><span class="line">  for (list* p = start; p != end; p = p-&gt;next) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, p-&gt;data);</span><br><span class="line">    if (p != end) printf(&quot;-&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Queues */</span><br><span class="line"></span><br><span class="line">typedef struct queue_header queue;</span><br><span class="line">struct queue_header &#123;</span><br><span class="line">  list* front;</span><br><span class="line">  list* back;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void queue_print_unsafe(queue* Q)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;[front] &quot;);</span><br><span class="line">  print_segment(Q-&gt;front, Q-&gt;back);</span><br><span class="line">  printf(&quot; [back]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_queue(queue* Q) &#123;</span><br><span class="line">  return Q != NULL</span><br><span class="line">      &amp;&amp; is_acyclic(Q-&gt;front)</span><br><span class="line">      &amp;&amp; is_segment(Q-&gt;front, Q-&gt;back);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_queue_internal(queue* Q)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">&#123;</span><br><span class="line">  queue_print_unsafe(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool queue_empty(queue* Q)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">&#123;</span><br><span class="line">  return Q-&gt;front == Q-&gt;back;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue* queue_new()</span><br><span class="line">//@ensures is_queue(\result);</span><br><span class="line">//@ensures queue_empty(\result);</span><br><span class="line">&#123;</span><br><span class="line">  queue* Q = alloc(queue);</span><br><span class="line">  list* l = alloc(list);</span><br><span class="line">  Q-&gt;front = l;</span><br><span class="line">  Q-&gt;back = l;</span><br><span class="line">  return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void enq(queue* Q, string s)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">//@ensures is_queue(Q);</span><br><span class="line">//@ensures !queue_empty(Q);</span><br><span class="line">&#123;</span><br><span class="line">  list* l = alloc(list);</span><br><span class="line">  Q-&gt;back-&gt;data = s;</span><br><span class="line">  Q-&gt;back-&gt;next = l;</span><br><span class="line">  Q-&gt;back = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string deq(queue* Q)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">//@requires !queue_empty(Q);</span><br><span class="line">//@ensures is_queue(Q);</span><br><span class="line">&#123;</span><br><span class="line">  string s = Q-&gt;front-&gt;data;</span><br><span class="line">  Q-&gt;front = Q-&gt;front-&gt;next;</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void queue_print(queue* Q)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;FRONT: &quot;);</span><br><span class="line">  for (list* l = Q-&gt;front; l != Q-&gt;back; l = l-&gt;next) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, l-&gt;data);</span><br><span class="line">    if (l-&gt;next != Q-&gt;back) printf(&quot; &lt;&lt; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot; :BACK&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client type</span><br><span class="line">typedef queue* queue_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/******************************* Interface ******************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* queue_t;</span><br><span class="line"></span><br><span class="line">bool queue_empty(queue_t Q)       /* O(1) */</span><br><span class="line">/*@requires Q != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">queue_t queue_new()               /* O(1) */</span><br><span class="line">/*@ensures \result != NULL; @*/</span><br><span class="line">/*@ensures queue_empty(\result); @*/ ;</span><br><span class="line"></span><br><span class="line">void enq(queue_t Q, string e)     /* O(1) */</span><br><span class="line">/*@requires Q != NULL; @*/</span><br><span class="line">/*@ensures !queue_empty(Q); @*/ ;</span><br><span class="line"></span><br><span class="line">string deq(queue_t Q)             /* O(1) */</span><br><span class="line">/*@requires Q != NULL; @*/</span><br><span class="line">/*@requires !queue_empty(Q); @*/ ;</span><br><span class="line"></span><br><span class="line">void queue_print(queue_t Q)       /* O(n) */</span><br><span class="line">/*@requires Q != NULL; @*/ ;</span><br></pre></td></tr></table></figure>
<h1 id="linked-lists">Linked lists</h1>
<p>链表是一种使用指针连接元素的数据结构，每个元素包含数据和指向下一个元素的指针。节点（Node）是链表的基本单元，包含数据和指向下一个节点的指针。</p>
<p>链表的递归类型：struct list_node { int data; list* next; }。链表的头指针指向链表的第一个节点。：<br>
在链表头部插入：时间复杂度 O(1)。在链表尾部插入：时间复杂度 O(n)，需要遍历整个链表。<br>
从链表头部删除：时间复杂度 O(1)。从链表尾部删除：时间复杂度 O(n)，需要遍历整个链表。</p>
<p>龟兔算法（Tortoise and Hare Algorithm）：使用两个指针（一个慢指针，一个快指针）来检测链表中是否存在循环。</p>
<p>使用链表可以实现Stack和Queue。</p>
<p>数组（未排序）：</p>
<ul>
<li>优点：O(1) 访问时间，内置的自适应大小。</li>
<li>缺点：固定大小，插入和删除操作时间复杂度为 O(n)。<br>
链表：</li>
<li>优点：自适应大小，O(1) 插入和删除操作（给定正确的指针）。</li>
<li>缺点：O(n) 访问时间，没有特殊的语法。</li>
</ul>
<h1 id="unbounded-array">Unbounded Array</h1>
<p>理解Unbounded Array(UBA)可能需要一些context。我们知道访问Array的复杂度是O(1)，并且我们在分配内存的时候赋予其固定长度。访问链表的复杂度是O(n)，但是其size是可变的。而UBA则结合了这两种结构的优势，提供了O(1)的访问复杂度，并且在数组满时扩张成更大的数组。</p>
<h2 id="interface">Interface</h2>
<ul>
<li>uba_len(uba_t A)：获取数组长度，时间复杂度 O(1)。</li>
<li>uba_new(int size)：创建一个新的无界数组，时间复杂度 O(size)。</li>
<li>uba_get(uba_t A, int i)：获取数组中索引为i的元素，时间复杂度 O(1)。</li>
<li>uba_set(uba_t A, int i, string x)：设置数组中索引为i的元素为x，时间复杂度 O(1)。</li>
<li>uba_add(uba_t A, string x)：在数组末尾添加元素x，时间复杂度 O(1)（摊销复杂度）。</li>
<li>uba_rem(uba_t A)：移除并返回数组的最后一个元素，时间复杂度 O(1)（摊销复杂度）。</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>数据结构：使用一个结构体uba_header来表示无界数组，包含数组的长度（size）、容量（limit）和数据（data）。<br>
扩容策略：当数组满时，通过创建一个更大的数组并将元素复制过去来实现扩容。</p>
<h3 id="sample-implementation">Sample Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#use &lt;util&gt;</span><br><span class="line">#use &lt;string&gt;</span><br><span class="line">#use &lt;conio&gt;</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">typedef struct uba_header uba;</span><br><span class="line">struct uba_header &#123;</span><br><span class="line">  int size;          // 0 &lt;= size &amp;&amp; size &lt; limit</span><br><span class="line">  int limit;         // 0 &lt; limit</span><br><span class="line">  string[] data;     // \length(data) == limit</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Internal debugging function that prints an UBA without checking contracts</span><br><span class="line">// (useful to debug representation invariant issues)</span><br><span class="line">void uba_print_unsafe(uba* A)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;UBA limit=%d; length=%d; data=[&quot;, A-&gt;limit, A-&gt;size);</span><br><span class="line">  for (int i = 0; i &lt; A-&gt;limit; i++)</span><br><span class="line">  //@loop_invariant 0 &lt;= i &amp;&amp; i &lt;= A-&gt;limit;</span><br><span class="line">  &#123;</span><br><span class="line">    if (i &lt; A-&gt;size)</span><br><span class="line">      printf(&quot;%s&quot;, A-&gt;data[i]);</span><br><span class="line">    else</span><br><span class="line">      printf(&quot;X&quot;);</span><br><span class="line">    if (i &lt; A-&gt;limit-1) &#123;</span><br><span class="line">      if (i == A-&gt;size-1) printf(&quot; | &quot;);</span><br><span class="line">      else printf(&quot;, &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_array_expected_length(string[] A, int length) &#123;</span><br><span class="line">  //@assert \length(A) == length;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_uba(uba* A) &#123;</span><br><span class="line">  return A != NULL</span><br><span class="line">      &amp;&amp; 0 &lt;= A-&gt;size &amp;&amp; A-&gt;size &lt; A-&gt;limit</span><br><span class="line">      &amp;&amp; is_array_expected_length(A-&gt;data, A-&gt;limit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Internal debugging function that prints an SSA</span><br><span class="line">// (useful to spot bugs that do not invalidate the representation invariant)</span><br><span class="line">void uba_print_internal(uba* A)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  uba_print_unsafe(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Implementation of exported functions</span><br><span class="line">int uba_len(uba* A)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@ensures 0 &lt;= \result &amp;&amp; \result &lt; \length(A-&gt;data);</span><br><span class="line">&#123;</span><br><span class="line">  return A-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string uba_get(uba* A, int i)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@requires 0 &lt;= i &amp;&amp; i &lt; uba_len(A);</span><br><span class="line">&#123;</span><br><span class="line">  return A-&gt;data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uba_set(uba* A, int i, string x)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@requires 0 &lt;= i &amp;&amp; i &lt; uba_len(A);</span><br><span class="line">//@ensures is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  A-&gt;data[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uba* uba_new(int size)</span><br><span class="line">//@requires 0 &lt;= size;</span><br><span class="line">//@ensures is_uba(\result);</span><br><span class="line">//@ensures uba_len(\result) == size;</span><br><span class="line">&#123;</span><br><span class="line">  uba* A = alloc(uba);</span><br><span class="line">  int limit = size == 0 ? 1 : size*2;</span><br><span class="line">  A-&gt;data = alloc_array(string, limit);</span><br><span class="line">  A-&gt;size = size;</span><br><span class="line">  A-&gt;limit = limit;</span><br><span class="line"></span><br><span class="line">  return A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uba_resize(uba* A, int new_limit)</span><br><span class="line">/* A may not be a valid array since A-&gt;size == A-&gt;limit is possible! */</span><br><span class="line">//@requires A != NULL;</span><br><span class="line">//@requires 0 &lt;= A-&gt;size &amp;&amp; A-&gt;size &lt; new_limit;</span><br><span class="line">//@requires \length(A-&gt;data) == A-&gt;limit;</span><br><span class="line">//@ensures is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  string[] B = alloc_array(string, new_limit);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; A-&gt;size; i++)</span><br><span class="line">    //@loop_invariant 0 &lt;= i;</span><br><span class="line">    &#123;</span><br><span class="line">      B[i] = A-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  A-&gt;limit = new_limit;</span><br><span class="line">  A-&gt;data = B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uba_add(uba* A, string x)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@ensures is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  A-&gt;data[A-&gt;size] = x;</span><br><span class="line">  (A-&gt;size)++;</span><br><span class="line"></span><br><span class="line">  if (A-&gt;size &lt; A-&gt;limit) return;</span><br><span class="line">  assert(A-&gt;limit &lt;= int_max() / 2); // Fail if array would get too big</span><br><span class="line">  uba_resize(A, A-&gt;limit * 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string uba_rem(uba* A)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@requires 0 &lt; uba_len(A);</span><br><span class="line">//@ensures is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  (A-&gt;size)--;</span><br><span class="line">  string x = A-&gt;data[A-&gt;size];</span><br><span class="line"></span><br><span class="line">  if (A-&gt;limit &gt;= 4 &amp;&amp; A-&gt;size &lt;= A-&gt;limit / 4)</span><br><span class="line">    uba_resize(A, A-&gt;limit / 2);</span><br><span class="line"></span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uba_print(uba* A)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;[&quot;);</span><br><span class="line">  for (int i = 0; i &lt; A-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;%s&quot;, A-&gt;data[i]);</span><br><span class="line">      if (i+1 != A-&gt;size) printf(&quot;, &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  printf(&quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Client type</span><br><span class="line">typedef uba* uba_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/******************************* Interface ******************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* uba_t;</span><br><span class="line"></span><br><span class="line">int uba_len(uba_t A)</span><br><span class="line">/*@requires A != NULL;   @*/</span><br><span class="line">/*@ensures \result &gt;= 0; @*/ ;</span><br><span class="line"></span><br><span class="line">uba_t uba_new(int size)</span><br><span class="line">/*@requires 0 &lt;= size;               @*/</span><br><span class="line">/*@ensures \result != NULL;          @*/</span><br><span class="line">/*@ensures uba_len(\result) == size; @*/ ;</span><br><span class="line"></span><br><span class="line">string uba_get(uba_t A, int i)</span><br><span class="line">/*@requires A != NULL;                @*/</span><br><span class="line">/*@requires 0 &lt;= i &amp;&amp; i &lt; uba_len(A); @*/ ;</span><br><span class="line"></span><br><span class="line">void uba_set(uba_t A, int i, string x)</span><br><span class="line">/*@requires A != NULL;                @*/</span><br><span class="line">/*@requires 0 &lt;= i &amp;&amp; i &lt; uba_len(A); @*/ ;</span><br><span class="line"></span><br><span class="line">void uba_add(uba_t A, string x)</span><br><span class="line">/*@requires A != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">string uba_rem(uba_t A)</span><br><span class="line">/*@requires A != NULL;      @*/</span><br><span class="line">/*@requires 0 &lt; uba_len(A); @*/ ;</span><br><span class="line"></span><br><span class="line">// bonus function</span><br><span class="line">void uba_print(uba_t A)</span><br><span class="line">/*@requires A != NULL;      @*/ ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="amortized-analysis">Amortized Analysis</h2>
<p>我们做Amortized Analysis的动机是估计不同函数/算法的runtime。之前的Worst-case analysis提供了runtime的上界。但其假定了每次对于函数的调用都有一样的runtime，并且有可能很大程度的夸张了资源耗费。Amortized Analysis将worst-case cost分配到整个操作序列上，使得其在分析一个操作序列中某一个操作序列的cost时很有用。 也用于分析那些在最坏情况下成本较高，但通过一系列操作可以摊销到较低平均成本的操作。例如，动态数组的扩容、链表的插入和删除等。</p>
<p>我们有两种进行Amortized Analysis的方法。<br>
一个比较方便的表示方法是使用token来表示操作的耗费（e.g. 1 token for push, 1 token for pop），在实际数据结构分析时判断每个操作本身所需的token和其隐含的token，这样就可以给每个操作得到固定的token值，再做平均。在对于多个操作组成的序列(e.g. push and pop from a stack)做分析时比较有用。</p>
<ol>
<li>Identify cost of future operations to save tokens for (e.g. resizing an array, moving elements over)</li>
<li>How many current operations do we perform before the future operation?(divide # of tokens to save by # of current ops that lead up to the future op)</li>
<li>Compute amortized cost(cost of operation itself + cost saved for future ops)</li>
</ol>
<p>另一种方法是计算一个序列的操作耗费然后除以操作次数，只有操作序列中只有一种操作时适用(e.g. uba_add)。</p>
<ol>
<li>Start having just finished an expensive operation.</li>
<li>Count # of operations until the next expensive operation.</li>
<li>Compute amortized cost (cost of sequence / # of ops in sequence)</li>
</ol>
<h1 id="hashing">Hashing</h1>
<ul>
<li><strong>哈希表</strong>：一种数据结构，通过哈希函数将键映射到表中的索引，解决键值对的存储和检索问题。</li>
<li><strong>哈希表操作</strong>：插入、查找、删除。</li>
</ul>
<p>不同的键可能映射到同一个索引，需要解决collision问题。</p>
<ul>
<li><strong>开放寻址法</strong>（Open Addressing）：在表中寻找下一个空闲位置。</li>
<li><strong>链地址法</strong>（Separate Chaining）：每个索引包含一个链表，所有映射到该索引的键值对都存储在这个链表中。</li>
</ul>
<p>如果所有桶（buckets）中的条目数量相同，则查找和插入操作的平均成本是 O(1)。如果所有条目都映射到同一个桶，则查找和插入操作的成本是 O(n)。通过适当调整哈希表的大小，可以保持插入操作的摊销成本为 O(1)。</p>
<p>哈希函数将键转换为哈希值的函数，理想的哈希函数应产生均匀分布的哈希值，减少碰撞。线性同余生成器（Linear Congruential Generator, LCG）是一种常见的伪随机数生成器，用于生成哈希值。</p>
<h2 id="generic-pointers">Generic Pointers</h2>
<p>传统的数据结构如栈（stacks）通常针对特定类型的元素设计，例如字符串或整数。为不同类型的元素创建栈需要复制和修改相同的代码，这导致代码重复且难以维护。</p>
<p>使用<code>elem</code>作为泛型类型名，让客户端代码定义<code>elem</code>的实际类型。客户端需要在客户端接口中定义<code>elem</code>的类型，例如<code>typedef string elem;</code>或<code>typedef int elem;</code>。</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>单一的库可以用于任何类型的栈。</li>
<li>如果需要不同类型的栈，只需在客户端适当地定义<code>elem</code>。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>客户端应用程序需要分割成两个文件，一个包含客户端定义，另一个包含其余的客户端应用程序代码。</li>
<li>强制使用不自然的编译模式，例如需要先编译库文件再编译客户端应用程序文件。</li>
<li>客户端应用程序最多只能包含一种类型的栈，因为<code>elem</code>的定义在整个应用程序中必须是一致的。</li>
</ul>
</li>
</ul>
<p>C1是C0语言的扩展，提供了泛型指针和函数指针，以增强泛型性。C1引入了<code>void*</code>指针类型，允许将任何类型的指针转换为<code>void*</code>，然后再转换回原始类型。</p>
<p>在栈的实现中，使用<code>void*</code>作为元素类型。将任何类型的元素转换为<code>void*</code>指针，以便在栈中存储和检索。C1语言在运行时会对<code>void*</code>指针进行检查，确保在转换回特定类型指针时类型匹配。如果错误地将<code>void*</code>转换为错误的类型，将导致运行时错误。</p>
<p>除了泛型指针，C1还提供了函数指针，允许将函数的地址作为值存储和传递。</p>
<h2 id="hash-dictionary">Hash Dictionary</h2>
<p>使用哈希表实现的字典，提供了快速的数据查找功能。字典中的每个条目包含一个键（key）和一个关联的数据（value）。</p>
<p>哈希表使用分链哈希表（separate-chaining hash table）实现，具有初始容量，可能支持自适应调整大小。</p>
<ul>
<li><strong>类型定义</strong>：<code>hdict_t</code> 用于操作字典，<code>key</code> 和 <code>entry</code> 为键和条目的类型。</li>
<li><strong>操作函数</strong>：
<ul>
<li><code>hdict_new(int capacity)</code>：创建新字典。</li>
<li><code>hdict_lookup(hdict_t D, key k)</code>：在字典中查找键。</li>
<li><code>hdict_insert(hdict_t D, entry e)</code>：向字典中插入条目。</li>
</ul>
</li>
</ul>
<p>客户端需要提供键的哈希值、键的比较函数等信息给库。客户端需要在接口中定义获取条目键、计算键的哈希值和比较两个键是否相同的函数。</p>
<p>哈希字典的每个链表节点包含数据和指向下一个节点的指针。字典头部包含字典的大小、容量和指向链表节点数组的指针。表示不变式确保字典的内部结构满足特定的条件，如链表无环、条目不为空等。</p>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#use &lt;util&gt;</span><br><span class="line">#use &lt;conio&gt;</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/**************************** Client Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* entry;               // Supplied by client</span><br><span class="line">// typedef ______  key;                 // Supplied by client</span><br><span class="line"></span><br><span class="line">key  entry_key(entry x)                 // Supplied by client</span><br><span class="line">  /*@requires x != NULL; @*/ ;</span><br><span class="line">int  key_hash(key k);                   // Supplied by client</span><br><span class="line">bool key_equiv(key k1, key k2);         // Supplied by client</span><br><span class="line"></span><br><span class="line">/************************* End Client Interface *************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">typedef struct chain_node chain;</span><br><span class="line">struct chain_node &#123;</span><br><span class="line">  entry  data;           // != NULL; contains both key and value</span><br><span class="line">  chain* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct hdict_header hdict;</span><br><span class="line">struct hdict_header &#123;</span><br><span class="line">  int size;              // 0 &lt;= size</span><br><span class="line">  chain*[] table;        // \length(table) == capacity</span><br><span class="line">  int capacity;          // 0 &lt; capacity</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_array_expected_length(chain*[] table, int length) &#123;</span><br><span class="line">  //@assert \length(table) == length;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_hdict(hdict* H) &#123;</span><br><span class="line">  return H != NULL</span><br><span class="line">      &amp;&amp; H-&gt;capacity &gt; 0</span><br><span class="line">      &amp;&amp; H-&gt;size &gt;= 0</span><br><span class="line">      &amp;&amp; is_array_expected_length(H-&gt;table, H-&gt;capacity);</span><br><span class="line">   /* &amp;&amp; table contains correct number non-NULL entries in correct places */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int index_of_key(hdict* H, key k)</span><br><span class="line">//@requires is_hdict(H);</span><br><span class="line">//@ensures 0 &lt;= \result &amp;&amp; \result &lt; H-&gt;capacity;</span><br><span class="line">&#123;</span><br><span class="line">  return abs(key_hash(k) % H-&gt;capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hdict* hdict_new(int capacity)</span><br><span class="line">//@requires capacity &gt; 0;</span><br><span class="line">//@ensures is_hdict(\result);</span><br><span class="line">&#123;</span><br><span class="line">  hdict* H = alloc(hdict);</span><br><span class="line">  H-&gt;size = 0;</span><br><span class="line">  H-&gt;capacity = capacity;</span><br><span class="line">  H-&gt;table = alloc_array(chain*, capacity);</span><br><span class="line">  return H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry hdict_lookup(hdict* H, key k)</span><br><span class="line">//@requires is_hdict(H);</span><br><span class="line">//@ensures \result == NULL || key_equiv(entry_key(\result), k);</span><br><span class="line">&#123;</span><br><span class="line">  int i = index_of_key(H, k);</span><br><span class="line">  for (chain* p = H-&gt;table[i]; p != NULL; p = p-&gt;next) &#123;</span><br><span class="line">    if (key_equiv(entry_key(p-&gt;data), k))</span><br><span class="line">      return p-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hdict_insert(hdict* H, entry x)</span><br><span class="line">//@requires is_hdict(H);</span><br><span class="line">//@requires x != NULL;</span><br><span class="line">//@ensures is_hdict(H);</span><br><span class="line">//@ensures hdict_lookup(H, entry_key(x)) == x;</span><br><span class="line">&#123;</span><br><span class="line">  key k = entry_key(x);</span><br><span class="line">  int i = index_of_key(H, k);</span><br><span class="line">  for (chain* p = H-&gt;table[i]; p != NULL; p = p-&gt;next) &#123;</span><br><span class="line">    //@assert p-&gt;data != NULL;  // From preconditions -- operational reasoning!</span><br><span class="line">    if (key_equiv(entry_key(p-&gt;data), k)) &#123;</span><br><span class="line">      p-&gt;data = x;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // prepend new entry</span><br><span class="line">  chain* p = alloc(chain);</span><br><span class="line">  p-&gt;data = x;</span><br><span class="line">  p-&gt;next = H-&gt;table[i];</span><br><span class="line">  H-&gt;table[i] = p;</span><br><span class="line">  (H-&gt;size)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Statistics</span><br><span class="line">int chain_length(chain* p) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  while (p != NULL) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// report the distribution stats for the hashtable</span><br><span class="line">void hdict_stats(hdict* H)</span><br><span class="line">//@requires is_hdict(H);</span><br><span class="line">&#123;</span><br><span class="line">  int max = 0;</span><br><span class="line">  int[] A = alloc_array(int, 11);</span><br><span class="line">  for(int i = 0; i &lt; H-&gt;capacity; i++) &#123;</span><br><span class="line">    int j = chain_length(H-&gt;table[i]);</span><br><span class="line">    if (j &gt; 9) A[10]++;</span><br><span class="line">    else A[j]++;</span><br><span class="line">    if (j &gt; max) max = j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Hash table distribution: how many chains have size...\n&quot;);</span><br><span class="line">  for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    printf(&quot;...%d:   %d\n&quot;, i, A[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;...10+: %d\n&quot;, A[10]);</span><br><span class="line">  printf(&quot;Longest chain: %d\n&quot;, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client-side type</span><br><span class="line">typedef hdict* hdict_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/*************************** Library Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* hdict_t;</span><br><span class="line"></span><br><span class="line">hdict_t hdict_new(int capacity)</span><br><span class="line">/*@requires capacity &gt; 0; @*/</span><br><span class="line">/*@ensures \result != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">entry hdict_lookup(hdict_t H, key k)</span><br><span class="line">/*@requires H != NULL; @*/</span><br><span class="line">/*@ensures \result == NULL || key_equiv(entry_key(\result), k); @*/ ;</span><br><span class="line"></span><br><span class="line">void hdict_insert(hdict_t H, entry x)</span><br><span class="line">/*@requires H != NULL &amp;&amp; x != NULL; @*/</span><br><span class="line">/*@ensures hdict_lookup(H, entry_key(x)) == x; @*/ ;</span><br></pre></td></tr></table></figure>
<h2 id="generic-hash-dictionary">Generic Hash Dictionary</h2>
<p>泛型数据结构如哈希字典，其操作对数据类型是不可知的，可以用于任何类型的键和条目。泛型库允许客户端选择数据类型,可以在同一个应用程序中使用不同数据类型的多个实例。</p>
<p>哈希字典的泛型实现通过将键和条目类型定义为 <code>void*</code> 来实现泛型。客户端需要提供 <code>entry_key</code>, <code>key_hash</code>, 和 <code>key_equiv</code> 函数来处理键和条目的具体类型。客户端必须定义自己的 <code>entry</code> 和 <code>key</code> 类型，并提供相应的函数来满足库的接口。为了避免在客户端代码中重复定义相同的函数名，可以通过为客户端函数提供不同的名称（如 <code>key_hash_produce</code>）来解决。</p>
<p>通过将哈希字典库升级为使用 <code>void*</code> 类型，简化了客户端的使用，允许在同一个应用程序中使用不同的数据类型。哈希函数和等价函数需要和谐，即具有相同哈希值的键应该是等价的。</p>
<p>在这里需要提到Hash dictionary分为Generic Dictionaries和Half-Generic Dictionaries。其中Generic Dictionaries是整个字典都是泛型，也就是把key和entry都定义成void*，并且由client提供key_hash, entry_key和key_equiv函数。client提供的函数里面也要把void* cast成需要的指针类型后进行操作，最后把操作结束得到的指针cast回entry或者key类型。<br>
另一个Half-Generic的类型即指entry和key是有具体的类型的，而上述提到的函数也是library implementation中就已经有定义，client直接调用即可。<br>
上述两种情况中，Half-Generic适合使用在已经明确了任务需要处理的数据类型的情况，Generic适合更宽泛的Dictionary任务。</p>
<p>C0 语言的内存模型包括局部内存、分配内存、堆（heap）、栈（stack）、文本段（TEXT），数据段（DATA）和OS。 Heap等价于alloc memory(stores local variables and function call information)，Stack等价于local memory(stores data with a lifetime not tied to the function call stack, allocated and freed by the programmer)，Text(contains executable code of the program), Data(stores global and static variables that are initialized with a value or values that are not explicitly initialized), 和OS(system calls, interrupts and other OS-related function)。C1 语言扩展了 C0，允许使用函数指针，即可以存储和操作指向函数的指针。使用 <code>&amp;</code> 操作符获取函数的地址。将函数指针存储在变量或数据结构中。通过解引用函数指针来调用指向的函数。</p>
<p>函数类型的声明使用 <code>typedef</code> 为函数指针创建类型，如 <code>typedef int string_to_int_fn(string s);</code>。</p>
<p>函数指针是指针的一种，需要确保在使用前不为 NULL。C1 语言确保程序中的函数地址从不为 NULL，从而保证了函数指针的使用安全。函数指针允许动态调用函数，可以在运行时根据需要选择不同的函数来执行。</p>
<h1 id="binary-search-tree">Binary Search Tree</h1>
<p><strong>二叉搜索树</strong>是一种特殊的二叉树，其中每个节点的值都大于或等于其左子树中任何节点的值，并且小于或等于其右子树中任何节点的值。目标是开发一种数据结构，确保查找（lookup）、插入（insert）和查找最小元素（find_min）的最坏情况复杂度都是 O(log n)。</p>
<p>Quick Tree Facts:</p>
<ul>
<li>The empty tree is NULL</li>
<li>A leaf is a tree node with NULL left and right children</li>
<li>The height of a tree is the number of nodes in the longest path from the root to a leaf (inclusive)</li>
</ul>
<p><strong>哈希字典</strong>虽然平均情况下查找和插入操作的时间复杂度为 O(1)，但在最坏情况下可能会退化到 O(n)。<strong>二叉搜索树</strong>提供了一种保证最坏情况下时间复杂度为 O(log n) 的字典实现方式。</p>
<ul>
<li><strong>查找（Lookup）</strong>：利用二叉搜索树的结构，从根节点开始，根据键值比较，递归地在左子树或右子树中查找。</li>
<li><strong>插入（Insert）</strong>：与查找操作类似，找到正确的插入位置，然后将新元素插入到树中。</li>
<li><strong>查找最小元素（Find Min）</strong>：从根节点开始，一直沿着左子树向下查找，直到找到最小键值。</li>
<li><strong>节点结构</strong>：每个节点包含数据元素、指向左子树的指针和指向右子树的指针。</li>
<li><strong>递归性质</strong>：二叉搜索树可以被看作是空树，或者是由根节点和两个子树（左子树和右子树）组成的。</li>
<li><strong>Ordering invariant</strong>：For any <code>tree* T</code>, all entries in <code>T-&gt;left</code> must be less than <code>T-&gt;data</code>, and all entries in <code>T-&gt;right</code> must be greater than <code>T-&gt;data</code>.</li>
</ul>
<p>有序二叉树的最佳访问复杂度是O(log n)，最差复杂度是O(n)。在最佳case里面相当于进行二分查找，最差的case里面就是顺序查找一个链表。</p>
<ul>
<li><strong>is_bst</strong>：检查一个树是否是二叉搜索树。</li>
<li><strong>is_ordered</strong>：检查树中的节点是否满足二叉搜索树的顺序约束。</li>
</ul>
<h2 id="implementation">Implementation</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/************************************************************************/</span><br><span class="line">/**************************** Client Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* entry;        // Supplied by client</span><br><span class="line">// typedef ______  key;          // Supplied by client</span><br><span class="line"></span><br><span class="line">key entry_key(entry e)           // Supplied by client</span><br><span class="line">/*@requires e != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">int key_compare(key k1, key k2); // Supplied by client</span><br><span class="line"></span><br><span class="line">/************************* End Client Interface *************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">/* BSTs and auxiliary functions */</span><br><span class="line">typedef struct tree_node tree;</span><br><span class="line">struct tree_node &#123;</span><br><span class="line">  tree* left;</span><br><span class="line">  entry data;  // != NULL</span><br><span class="line">  tree* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Minimal tree representation check */</span><br><span class="line">bool is_tree(tree* T) &#123; // minimal</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  return T-&gt;data != NULL</span><br><span class="line">      &amp;&amp; is_tree(T-&gt;left)</span><br><span class="line">      &amp;&amp; is_tree(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* is_ordered(T, lo, hi) checks if all entries in T</span><br><span class="line"> * are strictly in the interval (lo,hi).</span><br><span class="line"> * lo = NULL represents -infinity; hi = NULL represents +infinity */</span><br><span class="line">bool is_ordered(tree* T, entry lo, entry hi)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  //@assert T-&gt;data != NULL;   // because is_tree(T)</span><br><span class="line">  key k = entry_key(T-&gt;data);</span><br><span class="line">  return (lo == NULL || key_compare(entry_key(lo), k) &lt; 0)</span><br><span class="line">      &amp;&amp; (hi == NULL || key_compare(k, entry_key(hi)) &lt; 0)</span><br><span class="line">      &amp;&amp; is_ordered(T-&gt;left, lo, T-&gt;data)</span><br><span class="line">      &amp;&amp; is_ordered(T-&gt;right, T-&gt;data, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_bst(tree* T) &#123;</span><br><span class="line">  return is_tree(T)</span><br><span class="line">      &amp;&amp; is_ordered(T, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry bst_lookup(tree* T, key k)</span><br><span class="line">//@requires is_bst(T);</span><br><span class="line">//@ensures \result == NULL || key_compare(entry_key(\result), k) == 0;</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  int cmp = key_compare(k, entry_key(T-&gt;data));</span><br><span class="line">  if (cmp == 0)  return T-&gt;data;</span><br><span class="line">  if (cmp &lt;  0)  return bst_lookup(T-&gt;left, k);</span><br><span class="line">  //@assert cmp &gt; 0;</span><br><span class="line">  return bst_lookup(T-&gt;right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Builds a singleton tree with just entry e</span><br><span class="line">tree* leaf(entry e)</span><br><span class="line">//@requires e != NULL;</span><br><span class="line">//@ensures is_bst(\result);</span><br><span class="line">&#123;</span><br><span class="line">  tree* T = alloc(tree);</span><br><span class="line">  T-&gt;data = e;</span><br><span class="line">  T-&gt;left  = NULL;  // Not necessary</span><br><span class="line">  T-&gt;right = NULL;  // Not necessary</span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* bst_insert(tree* T, entry e)</span><br><span class="line">//@requires is_bst(T) &amp;&amp; e != NULL;</span><br><span class="line">//@ensures is_bst(\result) &amp;&amp; \result != NULL;</span><br><span class="line">//@ensures bst_lookup(\result, entry_key(e)) == e;</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return leaf(e);</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  int cmp = key_compare(entry_key(e), entry_key(T-&gt;data));</span><br><span class="line">  if (cmp == 0)     T-&gt;data = e;</span><br><span class="line">  else if (cmp &lt; 0) T-&gt;left = bst_insert(T-&gt;left, e);</span><br><span class="line">  else &#123; //@assert cmp &gt; 0;</span><br><span class="line">    T-&gt;right = bst_insert(T-&gt;right, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******* Implementing the dictionaries ******/</span><br><span class="line"></span><br><span class="line">struct dict_header &#123;</span><br><span class="line">  tree* root;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct dict_header dict;</span><br><span class="line"></span><br><span class="line">bool is_dict(dict* D) &#123;</span><br><span class="line">  return D != NULL &amp;&amp; is_bst(D-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dict* dict_new()</span><br><span class="line">//@ensures is_dict(\result);</span><br><span class="line">&#123;</span><br><span class="line">  dict* D = alloc(dict);</span><br><span class="line">  D-&gt;root = NULL;         // Not necessary</span><br><span class="line">  return D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry dict_lookup(dict* D, key k)</span><br><span class="line">//@requires is_dict(D);</span><br><span class="line">//@ensures \result == NULL || key_compare(entry_key(\result), k) == 0;</span><br><span class="line">&#123;</span><br><span class="line">  return bst_lookup(D-&gt;root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dict_insert(dict* D, entry e)</span><br><span class="line">//@requires is_dict(D) &amp;&amp; e != NULL;</span><br><span class="line">//@ensures is_dict(D) &amp;&amp; dict_lookup(D, entry_key(e)) == e;</span><br><span class="line">&#123;</span><br><span class="line">  D-&gt;root = bst_insert(D-&gt;root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry dict_min(dict* D)  // Return the smallest entry (or NULL)</span><br><span class="line">//@requires is_dict(D);</span><br><span class="line">&#123;</span><br><span class="line">  if (D-&gt;root == NULL) return NULL;</span><br><span class="line">  tree* T = D-&gt;root;</span><br><span class="line">  while (T-&gt;left != NULL)</span><br><span class="line">    T = T-&gt;left;</span><br><span class="line">  return T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef dict* dict_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/*************************** Library Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* dict_t;</span><br><span class="line"></span><br><span class="line">dict_t dict_new()</span><br><span class="line">/*@ensures \result != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">entry dict_lookup(dict_t D, key k)</span><br><span class="line">/*@requires D != NULL; @*/</span><br><span class="line">/*@ensures \result == NULL</span><br><span class="line">        || key_compare(entry_key(\result), k) == 0; @*/ ;</span><br><span class="line"></span><br><span class="line">void dict_insert(dict_t D, entry e)</span><br><span class="line">/*@requires D != NULL &amp;&amp; e != NULL; @*/</span><br><span class="line">/*@ensures dict_lookup(D, entry_key(e)) == e; @*/ ;</span><br><span class="line"></span><br><span class="line">entry dict_min(dict_t D)</span><br><span class="line">/*@requires D != NULL; @*/ ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="avl-tree">AVL Tree</h1>
<p>AVL 树是一种自平衡的二叉搜索树，保证了树的高度始终保持在 O(log n) 的范围内，其中 n 是树中节点的数量。目标是开发一种数据结构，确保查找（lookup）、插入（insert）和查找最小元素（find_min）的最坏情况复杂度都是 O(log n)。</p>
<p>在 AVL 树中，查找、插入和 find_min这些操作的最坏情况复杂度为 O(log n)。普通的二叉搜索树在某些情况下（如插入序列是有序的）可能会退化成链表，导致操作复杂度变为 O(n)。</p>
<p>平衡树的高度在 O(log n) 范围内。自平衡树在插入新节点后，树能够自动保持平衡。</p>
<p>AVL 树的每个节点的左子树和右子树的高度差不超过 1。节点的值满足二叉搜索树的顺序条件。</p>
<p>为了维护 AVL 树的平衡条件，可能需要进行单旋转或双旋转。当右子树的高度大于左子树的高度时进行左旋转。当左子树的高度大于右子树的高度时进行右旋转。双旋转即先进行一次右旋转，再进行一次左旋转，或先进行一次左旋转，再进行一次右旋转。</p>
<p>AVL 树的插入策略像在 BST 中一样插入新节点，修复任何高度不变性违规，从最低违规开始修复。在 AVL 树中插入一个节点，如果导致高度违规，则通过旋转修复，修复后的树高度保持不变或只增加 1。单旋转或双旋转都可以在 O(1) 的时间内完成，确保插入操作的整体复杂度为 O(log n)。</p>
<p>AVL 字典接口与 BST 字典接口相同，但内部实现使用 AVL 树。AVL 字典实现在 BST 实现的基础上进行修改，增加高度不变性的维护。AVL 树的表示不变性确保 AVL 树的每个节点都满足顺序不变性和高度不变性。</p>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/************************************************************************/</span><br><span class="line">/**************************** Client Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* entry;        // Supplied by client</span><br><span class="line">// typedef ______  key;          // Supplied by client</span><br><span class="line"></span><br><span class="line">key entry_key(entry e)           // Supplied by client</span><br><span class="line">/*@requires e != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">int key_compare(key k1, key k2); // Supplied by client</span><br><span class="line"></span><br><span class="line">/************************* End Client Interface *************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">/* BSTs and auxiliary functions */</span><br><span class="line">typedef struct tree_node tree;</span><br><span class="line">struct tree_node &#123;</span><br><span class="line">  tree* left;</span><br><span class="line">  entry data;  // != NULL</span><br><span class="line">  tree* right;</span><br><span class="line">  int height;  // &gt; 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Minimal tree representation check */</span><br><span class="line">bool is_tree(tree* T) &#123; // minimal</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  return T-&gt;data != NULL</span><br><span class="line">      &amp;&amp; is_tree(T-&gt;left)</span><br><span class="line">      &amp;&amp; is_tree(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* is_ordered(T, lo, hi) checks if all entries in T</span><br><span class="line"> * are strictly in the interval (lo,hi).</span><br><span class="line"> * lo = NULL represents -infinity; hi = NULL represents +infinity */</span><br><span class="line">bool is_ordered(tree* T, entry lo, entry hi)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  //@assert T-&gt;data != NULL;   // because is_tree(T)</span><br><span class="line">  key k = entry_key(T-&gt;data);</span><br><span class="line">  return (lo == NULL || key_compare(entry_key(lo), k) &lt; 0)</span><br><span class="line">      &amp;&amp; (hi == NULL || key_compare(k, entry_key(hi)) &lt; 0)</span><br><span class="line">      &amp;&amp; is_ordered(T-&gt;left, lo, T-&gt;data)</span><br><span class="line">      &amp;&amp; is_ordered(T-&gt;right, T-&gt;data, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* UNUSED: cost is O(n)</span><br><span class="line">int height(tree* T)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">//@ensures \result &gt;= 0;</span><br><span class="line">&#123;</span><br><span class="line">  if (T == NULL) return 0;</span><br><span class="line">  return 1 + max(height(T-&gt;left), height(T-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int height(tree* T) // O(1)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">//@ensures \result &gt;= 0;</span><br><span class="line">&#123;</span><br><span class="line">  return T == NULL ? 0 : T-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_specified_height(tree* T) &#123;</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line">  return is_specified_height(T-&gt;left)     // height(T-&gt;left)  is correct</span><br><span class="line">      &amp;&amp; is_specified_height(T-&gt;right)    // height(T-&gt;right) is correct</span><br><span class="line">      &amp;&amp; T-&gt;height == max(height(T-&gt;left),</span><br><span class="line">                          height(T-&gt;right)) + 1; // height(T) is correct</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_balanced(tree* T)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">&#123;</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line">  return abs(height(T-&gt;left) - height(T-&gt;right)) &lt;= 1</span><br><span class="line">      &amp;&amp; is_balanced(T-&gt;left)</span><br><span class="line">      &amp;&amp; is_balanced(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_avl(tree* T) &#123;</span><br><span class="line">  return is_tree(T) &amp;&amp; is_ordered(T, NULL, NULL)</span><br><span class="line">      &amp;&amp; is_specified_height(T) &amp;&amp; is_balanced(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry avl_lookup(tree* T, key k)</span><br><span class="line">//@requires is_avl(T);</span><br><span class="line">//@ensures \result == NULL || key_compare(entry_key(\result), k) == 0;</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  int cmp = key_compare(k, entry_key(T-&gt;data));</span><br><span class="line">  if (cmp == 0)  return T-&gt;data;</span><br><span class="line">  if (cmp &lt;  0)  return avl_lookup(T-&gt;left, k);</span><br><span class="line">  //@assert cmp &gt; 0;</span><br><span class="line">  return avl_lookup(T-&gt;right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fix_height(tree* T)</span><br><span class="line">//@requires is_tree(T) &amp;&amp; T != NULL;</span><br><span class="line">//@requires is_specified_height(T-&gt;left);</span><br><span class="line">//@requires is_specified_height(T-&gt;right);</span><br><span class="line">//@ensures is_specified_height(T);</span><br><span class="line">&#123;</span><br><span class="line">  int hl = height(T-&gt;left);</span><br><span class="line">  int hr = height(T-&gt;right);</span><br><span class="line">  T-&gt;height = 1 + max(hl, hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* rotate_left(tree* T)</span><br><span class="line">//@requires T != NULL &amp;&amp; T-&gt;right != NULL;</span><br><span class="line">//@requires is_specified_height(T-&gt;left);</span><br><span class="line">//@requires is_specified_height(T-&gt;right);</span><br><span class="line">//@ensures is_specified_height(\result);</span><br><span class="line">&#123;</span><br><span class="line">  tree* temp = T-&gt;right;</span><br><span class="line">  T-&gt;right = T-&gt;right-&gt;left;</span><br><span class="line">  temp-&gt;left = T;</span><br><span class="line">  fix_height(T);</span><br><span class="line">  fix_height(temp);</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* rotate_right(tree* T)</span><br><span class="line">//@requires T != NULL &amp;&amp; T-&gt;left != NULL;</span><br><span class="line">//@requires is_specified_height(T-&gt;left);</span><br><span class="line">//@requires is_specified_height(T-&gt;right);</span><br><span class="line">//@ensures is_specified_height(\result);</span><br><span class="line">&#123;</span><br><span class="line">  tree* temp = T-&gt;left;</span><br><span class="line">  T-&gt;left = T-&gt;left-&gt;right;</span><br><span class="line">  temp-&gt;right = T;</span><br><span class="line">  fix_height(T);</span><br><span class="line">  fix_height(temp);</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* rebalance_right(tree* T)</span><br><span class="line">// T must be immediate result of a right-insertion</span><br><span class="line">//@requires T != NULL &amp;&amp; T-&gt;right != NULL;</span><br><span class="line">//@requires is_avl(T-&gt;left) &amp;&amp; is_avl(T-&gt;right);</span><br><span class="line">//@ensures is_avl(\result);</span><br><span class="line">&#123;</span><br><span class="line">  if (height(T-&gt;right) - height(T-&gt;left) == 2) &#123;   // violation!</span><br><span class="line">    if (height(T-&gt;right-&gt;right) &gt; height(T-&gt;right-&gt;left)) &#123;</span><br><span class="line">      // Single rotation</span><br><span class="line">      T = rotate_left(T);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //@assert height(T-&gt;right-&gt;left) &gt; height(T-&gt;right-&gt;right);</span><br><span class="line">      // Double rotation</span><br><span class="line">      T-&gt;right = rotate_right(T-&gt;right);</span><br><span class="line">      T = rotate_left(T);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123; // No rotation needed, but tree may have grown</span><br><span class="line">    fix_height(T);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* rebalance_left(tree* T)</span><br><span class="line">// T must be immediate result of a left-insertion</span><br><span class="line">//@requires T != NULL &amp;&amp; T-&gt;left != NULL;</span><br><span class="line">//@requires is_avl(T-&gt;left) &amp;&amp; is_avl(T-&gt;right);</span><br><span class="line">//@ensures is_avl(\result);</span><br><span class="line">&#123;</span><br><span class="line">  if (height(T-&gt;left) - height(T-&gt;right) == 2) &#123;   // violation!</span><br><span class="line">    if (height(T-&gt;left-&gt;left) &gt; height(T-&gt;left-&gt;right)) &#123;</span><br><span class="line">      // Single rotation</span><br><span class="line">      T = rotate_right(T);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //@assert height(T-&gt;left-&gt;right) &gt; height(T-&gt;left-&gt;left);</span><br><span class="line">      // Double rotation</span><br><span class="line">      T-&gt;left = rotate_left(T-&gt;left);</span><br><span class="line">      T = rotate_right(T);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123; // No rotation needed, but tree may have grown</span><br><span class="line">    fix_height(T);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Builds a singleton tree with just entry e</span><br><span class="line">tree* leaf(entry e)</span><br><span class="line">//@requires e != NULL;</span><br><span class="line">//@ensures is_avl(\result);</span><br><span class="line">&#123;</span><br><span class="line">  tree* T = alloc(tree);</span><br><span class="line">  T-&gt;data = e;</span><br><span class="line">  T-&gt;left  = NULL;  // Not necessary</span><br><span class="line">  T-&gt;right = NULL;  // Not necessary</span><br><span class="line">  T-&gt;height = 1;</span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* avl_insert(tree* T, entry e)</span><br><span class="line">//@requires is_avl(T) &amp;&amp; e != NULL;</span><br><span class="line">//@ensures is_avl(\result) &amp;&amp; \result != NULL;</span><br><span class="line">//@ensures avl_lookup(\result, entry_key(e)) == e;</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return leaf(e);</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  //@assert is_avl(T-&gt;left);</span><br><span class="line">  //@assert is_avl(T-&gt;right);</span><br><span class="line">  int cmp = key_compare(entry_key(e), entry_key(T-&gt;data));</span><br><span class="line">  if (cmp == 0)</span><br><span class="line">    T-&gt;data = e;</span><br><span class="line">  else if (cmp &lt; 0) &#123;  // Go left</span><br><span class="line">    T-&gt;left = avl_insert(T-&gt;left, e);</span><br><span class="line">    //@assert is_avl(T-&gt;left) &amp;&amp; T-&gt;left != NULL &amp;&amp; is_avl(T-&gt;right);</span><br><span class="line">    T = rebalance_left(T);</span><br><span class="line">    //@assert is_avl(T);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;               // Go right</span><br><span class="line">    //@assert cmp &gt; 0;</span><br><span class="line">    T-&gt;right = avl_insert(T-&gt;right, e);</span><br><span class="line">    //@assert is_avl(T-&gt;left) &amp;&amp; is_avl(T-&gt;right) &amp;&amp; T-&gt;right != NULL;</span><br><span class="line">    T = rebalance_right(T);</span><br><span class="line">    //@assert is_avl(T);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******* Implementing the dictionaries ******/</span><br><span class="line"></span><br><span class="line">struct dict_header &#123;</span><br><span class="line">  tree* root;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct dict_header dict;</span><br><span class="line"></span><br><span class="line">bool is_dict(dict* D) &#123;</span><br><span class="line">  return D != NULL &amp;&amp; is_avl(D-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dict* dict_new()</span><br><span class="line">//@ensures is_dict(\result);</span><br><span class="line">&#123;</span><br><span class="line">  dict* D = alloc(dict);</span><br><span class="line">  D-&gt;root = NULL;         // Not necessary</span><br><span class="line">  return D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry dict_lookup(dict* D, key k)</span><br><span class="line">//@requires is_dict(D);</span><br><span class="line">//@ensures \result == NULL || key_compare(entry_key(\result), k) == 0;</span><br><span class="line">&#123;</span><br><span class="line">  return avl_lookup(D-&gt;root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dict_insert(dict* D, entry e)</span><br><span class="line">//@requires is_dict(D) &amp;&amp; e != NULL;</span><br><span class="line">//@ensures is_dict(D);</span><br><span class="line">//@ensures dict_lookup(D, entry_key(e)) == e;</span><br><span class="line">&#123;</span><br><span class="line">  D-&gt;root = avl_insert(D-&gt;root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry dict_min(dict* D)  // Return the smallest entry (or NULL)</span><br><span class="line">//@requires is_dict(D);</span><br><span class="line">&#123;</span><br><span class="line">  if (D-&gt;root == NULL) return NULL;</span><br><span class="line">  tree* T = D-&gt;root;</span><br><span class="line">  while (T-&gt;left != NULL)</span><br><span class="line">    T = T-&gt;left;</span><br><span class="line">  return T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef dict* dict_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/*************************** Library Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* dict_t;</span><br><span class="line"></span><br><span class="line">dict_t dict_new()</span><br><span class="line">/*@ensures \result != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">entry dict_lookup(dict_t D, key k)</span><br><span class="line">/*@requires D != NULL; @*/</span><br><span class="line">/*@ensures \result == NULL</span><br><span class="line">        || key_compare(entry_key(\result), k) == 0; @*/ ;</span><br><span class="line"></span><br><span class="line">void dict_insert(dict_t D, entry e)</span><br><span class="line">/*@requires D != NULL &amp;&amp; e != NULL; @*/</span><br><span class="line">/*@ensures dict_lookup(D, entry_key(e)) == e; @*/ ;</span><br><span class="line"></span><br><span class="line">entry dict_min(dict_t D)</span><br><span class="line">/*@requires D != NULL; @*/ ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU 21127：Summary Sheet of Definitions &amp; Theorems</title>
    <url>/posts/cmu21127note1.html</url>
    <content><![CDATA[<h1 id="propositional-logic">Propositional Logic</h1>
<ul>
<li>Definition 0.1: Proposition is a statement to which it is possible to assign a truth value.</li>
<li>A <strong>proposition</strong> is an umbrella term which can be used for any result.</li>
<li>A <strong>theorem</strong> is a key result which is particularly important.</li>
<li>A <strong>lemma</strong> is a result which is proved for the purpose of being used in the proof of a theorem.</li>
<li>A <strong>corollary</strong> is a result which follows from a theorem without much additional effort.</li>
</ul>
<h1 id="sets-and-numbers">Sets and Numbers</h1>
<ul>
<li>Definition 0.3: A <strong>set</strong> is a collection of objects. The objects in the set are called <strong>elements</strong> of the set.</li>
<li>Definition 0.5: The <strong>natural numbers</strong> are represented by the points on the number line which can be obtained by starting at 0 and moving right by the unit length any number of times.</li>
</ul>
<h2 id="basis-for-natural-numbers">Basis for natural numbers</h2>
<ul>
<li>Definition 0.6: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b \gt 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. The <strong>base-b expansion</strong> of a natural number n is the string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>r</mi></msub><msub><mi>d</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>d</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">d_rd_{r-1}...d_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>d</mi><mi>r</mi></msub><mo>×</mo><msup><mi>b</mi><mi>r</mi></msup><mo>+</mo><msub><mi>d</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>×</mo><msup><mi>b</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><msup><mi>b</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">n = d_r \times b^r + d_{r-1} \times b^{r-1} + ... + d_0 \times b^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span> ;</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>d</mi><mi>i</mi></msub><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">0 \le d_i \lt b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> for each i; and</li>
<li>if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>r</mi></msub><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d_r \ne 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, the base-b expansion of zero is 0 in all cases b;</li>
</ul>
</li>
<li>Definition 0.11: The <strong>integers</strong> are represented by the points on the number line which can be obtained by starting at 0 and movnig in either direction by the unit length any number of times.</li>
<li>Definition 0.12: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">a, b \in Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>. We say b <strong>divides</strong> a if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>q</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a=qb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">b</span></span></span></span> for some integer q.</li>
<li>Proposition 0.15: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo>∈</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">a,b,c \in Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>. If c divides b and b divides a, then c divides a.</li>
<li>Definition 0.17: An integer n is even if it is divisible by 2; otherwise, n is odd.</li>
<li>Theorem 0.18: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">a,b \in Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b \ne 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. There is exactly one way to write<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>q</mi><mi>b</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">a = qb + r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><br>
such that q and r are integers, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>r</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">0 \le r \lt b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>(if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b \gt 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>), or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>r</mi><mo>&lt;</mo><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">0 \le r \lt -b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">b</span></span></span></span>(if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b \lt 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>).</li>
</ul>
<h2 id="algorithm-to-find-basis">Algorithm to find basis</h2>
<p>Given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">n \in N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>:</p>
<ul>
<li>Step 1: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">d_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> be the remainder when n is divided by b, and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><mfrac><mrow><mi>n</mi><mo>−</mo><msub><mi>d</mi><mn>0</mn></msub></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">n_0=\frac{n-d_0}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2412079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> be the quotient. Fix i = 0.</li>
<li>Step 2: Suppose <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> have been defined. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n_i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, then proceed to Step 3. Otherwise, define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">d_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> to be the remainder when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is divided by b, and define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>−</mo><msub><mi>d</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">n_{i+1} = \frac{n_i-d_i+1}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2412079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>. Increment i, and repeat Step 2.</li>
<li>Step 3: The base-b expansion of n, is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><msub><mi>d</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>d</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">d_id_{i-1}...d_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</li>
</ul>
<h2 id="rationals">Rationals</h2>
<ul>
<li>Definition 0.24: The <strong>rational numbers</strong> are represented by the points at the number line which can be obtained by dividing any of the unit line segments between integers into an equal number of parts.</li>
</ul>
<h2 id="real-numbers">Real numbers</h2>
<ul>
<li>Definition 0.25: The <strong>real numebrs</strong> are the points on the number line. We write R for the set of all real numbers.</li>
</ul>
<h2 id="irrational-numbers">Irrational numbers</h2>
<ul>
<li>Definition 0.27: An <strong>irrational number</strong> is a real number that is not rational.</li>
</ul>
<h2 id="complex-numbers">Complex numbers</h2>
<ul>
<li>Definition 0.31: The <strong>complex numbers</strong> are those obtained by the non-negative real numbers upon rotation by any angle about the point 0. We write C for the set of all complex numbers.</li>
</ul>
<p><img src="/posts/cmu21127note1.htm/cmu21127note1/Screenshot%202024-07-03%20195150.png" alt="Complex number"></p>
<ul>
<li>Addition corresponds to translation.</li>
<li>Multiplication correspond to rotation.</li>
</ul>
<p><strong>Omit complex conjugate here.</strong></p>
<h1 id="polynomials">Polynomials</h1>
<ul>
<li>Definition 0.32: Let S=N,Z,Q,R or C. A <strong>(univariate) polynomial over</strong> S in the <strong>indeterminate</strong> x is an expression of the form<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a_0+a_1x+...+a_nx^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.814392em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span><br>
Where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">n \in N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> and each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">a_k \in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>. The numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are called the <strong>coefficients</strong> of the polynomial. If not all coefficients are zero, the largest value of k for which <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_k \ne 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> is called the <strong>degree</strong> of the polynomial. By convention, the degree of the polynomial 0 is <span class="katex-error" title="ParseError: KaTeX parse error: Undefined control sequence: \infinity at position 2: -\̲i̲n̲f̲i̲n̲i̲t̲y̲">-\infinity</span></li>
<li>Definition 0.37: Let p(x) be a polynomial. A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> of p(x) is a complex number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p(\alpha)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>.</li>
<li>Omit the theorem of complex conjugate root.</li>
</ul>
<h1 id="sets">Sets</h1>
<ul>
<li>
<p>Axiom 2.1.22 (Sets extensionality)<br>
Let X and Y be sets. Then X = Y if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>a</mi><mo>∈</mo><mi>X</mi><mo>↔</mo><mi>a</mi><mo>∈</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall a, (a \in X \leftrightarrow a \in Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>, or equivalently, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊂</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \sub Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \sub X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>.</p>
</li>
<li>
<p>Definition 2.1.36<br>
Let X be a set. The <strong>power set</strong> of X, written <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>, is the set of all subsets of X.</p>
</li>
<li>
<p>Definition 2.2.8<br>
Let X and Y be sets. We say X and Y are <strong>disjoint</strong> if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∩</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \cap Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is empty.</p>
</li>
<li>
<p>Definition 2.2.18<br>
An <strong>(indexed) family of sets</strong> is a specification of a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for each element i of some <strong>indexing set</strong> I. We write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">{X_i | i \in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span></span> for the indexed family of sets.</p>
</li>
<li>
<p>Definition 2.2.20<br>
The <strong>(indexed) intersection</strong> of an indexed family <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">{X_i | i \in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span></span> is defined by<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⋂</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><mrow><mi>a</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mi>I</mi><mo separator="true">,</mo><mi>a</mi><mo>∈</mo><msub><mi>X</mi><mi>i</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\bigcap_{i \in I} X_i = {a | \forall i \in I, a \in X_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><br>
The <strong>(indexed) union</strong> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">{X_i | i \in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span></span> is defined by<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⋃</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><mrow><mi>a</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∃</mi><mi>i</mi><mo>∈</mo><mi>I</mi><mo separator="true">,</mo><mi>a</mi><mo>∈</mo><msub><mi>X</mi><mi>i</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\bigcup_{i \in I} X_i = {a | \exists i \in I, a \in X_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord">∃</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>Definition 2.2.26<br>
Let X and Y be sets. The <strong>relative complement</strong> of Y in X, denoted <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∖</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \setminus Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>, is defined by<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∖</mo><mi>Y</mi><mo>=</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo mathvariant="normal">∉</mo><mi>Y</mi></mrow></mrow><annotation encoding="application/x-tex">X \setminus Y = {x \in X | x \notin Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></span><br>
The operation is also known as the <strong>set difference</strong> operation. Some authors write Y - X instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>∖</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \setminus X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>.</p>
</li>
<li>
<p>Theorem 2.2.31 (De Morgan’s Laws for sets)<br>
Given sets A, X, Y and a family <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">{X_i | i \in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span></span>, we have<br>
(a) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∖</mo><mo stretchy="false">(</mo><mi>X</mi><mo>∪</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo>∖</mo><mi>X</mi><mo stretchy="false">)</mo><mo>∩</mo><mo stretchy="false">(</mo><mi>A</mi><mo>∖</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \setminus (X \cup Y) = (A \setminus X) \cap (A \setminus Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><br>
(b) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∖</mo><mo stretchy="false">(</mo><mi>X</mi><mo>∩</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo>∖</mo><mi>X</mi><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mi>A</mi><mo>∖</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \setminus (X \cap Y) = (A \setminus X) \cup (A \setminus Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><br>
© <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∖</mo><msub><mo>⋃</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><msub><mo>⋂</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo>∖</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \setminus \bigcup_{i \in I} X_i = \bigcap_{i \in I}(A \setminus X_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
(d) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∖</mo><msub><mo>⋂</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><msub><mo>⋃</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo>∖</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \setminus \bigcap_{i \in I} X_i = \bigcup_{i \in I}(A \setminus X_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>Definition 2.2.33<br>
Let X and Y be sets. The <strong>(pairwise) cartesian product</strong> of X and Y is the set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \times Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> defined by<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>a</mi><mo>∈</mo><mi>X</mi><mo>∧</mo><mi>b</mi><mo>∈</mo><mi>Y</mi></mrow></mrow><annotation encoding="application/x-tex">X \times Y = {(a, b) | a \in X \wedge b \in Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></span><br>
The elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">(a,b) \in X \times Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> are called <strong>ordered pairs</strong>, whose defining property is that, for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a, x \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> and all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">b, y \in Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>, we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b) = (x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> if and only if a = x and b = y.</p>
</li>
<li>
<p>Definition 2.2.38<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">n \in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_1, X_2, ..., X_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> be sets. The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>f</mi><mi>o</mi><mi>l</mi><mi>d</mi><mo stretchy="false">)</mo><mi>c</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(n-fold)cartesian product</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_1, X_2, ..., X_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>X</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\prod_{k=1}^{n} X_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> defined by<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>=</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>k</mi></msub><mo>∈</mo><msub><mi>X</mi><mi>k</mi></msub><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow></mrow><annotation encoding="application/x-tex">\prod_{k=1}^{n} = {(a_1, a_2, ..., a_n) | a_k \in X_k, 1 \le k \le n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span></span></span></span></span><br>
The elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><msubsup><mo>∏</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>X</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">(a_1, a_2, ..., a_n) \in \prod_{k=1}^{n} X_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are called <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>k</mi><mo>−</mo><mi>t</mi><mi>u</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ordered k-tuples</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>, whose defining property is that, for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le k \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> and all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>k</mi></msub><mo>∈</mo><msub><mi>X</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k, b_k \in X_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1, a_2, ... ,a_n) = (b_1, b_2, ..., b_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo>=</mo><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k = b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le k \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>.<br>
Given a set X, write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">X^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> to denote the set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>X</mi></mrow><annotation encoding="application/x-tex">\prod_{k=1}^{n}X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>. We might on occasion also write<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>×</mo><msub><mi>X</mi><mn>2</mn></msub><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><msub><mi>X</mi><mi>n</mi></msub><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>X</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">X_1 \times X_2 \times ... \times X_n = \prod_{k=1}^{n}X_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>Definition 9.2.1<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">A \subseteq \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>. A real number m is an <strong>upper bound</strong> for A if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>. A <strong>supremum</strong> of A is a least upper bound of A; that is, a real number m such that:<br>
(i) m is an upper bound of A——that is, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>; and<br>
(ii) m is least amongst all upper bounds for A——that is, for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">x \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a \le x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">x \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>.</p>
</li>
<li>
<p>Theorem 9.2.5(Uniqueness of suprema)<br>
Let A be a subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">m_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">m_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are suprema of A, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>1</mn></msub><mo>=</mo><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">m_1 = m_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
</li>
<li>
<p>Axiom 9.2.7 (Completemess axiom)<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">A \subseteq \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> be inhabited. If A has an upper bound, then A has a supremum.</p>
</li>
<li>
<p>Definition 9.2.8<br>
If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">f: X \to \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> is a funciton and X is an arbitrary set, we define<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>p</mi><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></mrow><annotation encoding="application/x-tex">sup f(x) := sup{f(x) : x \in X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></span><br>
whenever the sup on RHS exists.</p>
</li>
<li>
<p>Definition 9.2.9<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \in \mathbb(N), n \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, we define the n-dimensional Euclidian space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> as follows:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi mathvariant="double-struck">R</mi><mo>=</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup><mo>:</mo><mo>=</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>:</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mi mathvariant="double-struck">R</mi><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mrow><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">\prod_{i = 1}^{n}\mathbb{R} = \mathbb{R}^n := {(x_1, x_2, x_n) : x_i \in \mathbb{R}, \forall i \in {1, ..., n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></span></span></p>
</li>
<li>
<p>Definition 9.2.10<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\vec{x}, \vec{y} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\lambda \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>, we define<br>
(sum) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{x} + \vec{y} = (x_1 + y_1, ... ,x_n + y_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79733em;vertical-align:-0.08333em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
(multiplication by scalar) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>λ</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda \vec{x} = (\lambda x_1, ..., \lambda x_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">λ</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
obs: The definition above does not say anything about multiplying vectors by another vector.</p>
</li>
<li>
<p>Definition 9.2.11<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\vec{x}, \vec{y} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>. The scalar or dot product of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span> is the real number defined as<br>
<span class="katex-error" title="ParseError: KaTeX parse error: Got function &#039;\vec&#039; with no arguments as argument to &#039;\dot&#039; at position 14: \vec{x} \dot \̲v̲e̲c̲{y} = &lt;\vec{x},…">\vec{x} \dot \vec{y} = &lt;\vec{x}, \vec{y}&gt; := \sum_{i=1}^{n}x_i y_i = x_1y_1 + ... + x_ny_n</span></p>
</li>
<li>
<p>Proposition 9.2.12<br>
For any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\vec{x} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7531em;vertical-align:-0.0391em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>, we have: <span class="katex-error" title="ParseError: KaTeX parse error: Got function &#039;\vec&#039; with no arguments as argument to &#039;\dot&#039; at position 30: …= \vec{x} \dot \̲v̲e̲c̲{x}">||\vec{x}||^2 = \vec{x} \dot \vec{x}</span></p>
</li>
<li>
<p>Theorem 9.2.13<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\vec{x}, \vec{y} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>. Then <span class="katex-error" title="ParseError: KaTeX parse error: Got function &#039;\vec&#039; with no arguments as argument to &#039;\dot&#039; at position 14: \vec{x} \dot \̲v̲e̲c̲{y} = ||\vec{x}…">\vec{x} \dot \vec{y} = ||\vec{x}||||\vec{y}||cos\theta</span><br>
The latter theorem says that vector x is orthogonal to vector y if and only if their scalar product is zero.</p>
</li>
<li>
<p>Theorem 9.1.16 (Cauchy-Schwarz inequality)<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">n \in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">x_i, y_i \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> for each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>. Then<br>
<span class="katex-error" title="ParseError: KaTeX parse error: Got function &#039;\vec&#039; with no arguments as argument to &#039;\dot&#039; at position 15: |\vec{x} \dot \̲v̲e̲c̲{y}| \le ||\vec…">|\vec{x} \dot \vec{y}| \le ||\vec{x}||||\vec{y}||</span><br>
with equality if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>=</mo><mi>b</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">a \vec{x} = b\vec{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">a, b \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> which are not both zero.</p>
</li>
<li>
<p>Theorem 9.2.17 (Triangle inequality)<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\vec{x}, \vec{y} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>. Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|| \vec{x} + \vec{y} || \le ||\vec{x}|| + ||\vec{y}||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span></span></span></span><br>
Equality holds if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>=</mo><mi>b</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">a\vec{x} = b\vec{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">a, b \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> which are noth zero and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a, b \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
</li>
<li>
<p>Theorem 9.2.18 (Parallelogram law)<br>
Given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\vec{x}, \vec{y} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>, we have<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>=</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>y</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">||\vec{x} + \vec{y}||^2 + ||\vec{x} - \vec{y}||^2 = 2||\vec{x}||^2 + 2||\vec{y}||^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><br>
Moreover, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> is orthogonal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>, then (Pitagoras theorem)<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><mi>y</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>=</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">||x - y||^2 = ||x||^2 + ||y||^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>Definition 9.1.20<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. The <strong>(arithmetic) mean</strong> of real numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, ..., x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n}\sum_{i=1}^{n}x_i = \frac{x_1 + x_2 + ... + x_n}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1634309999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184309999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p>Definition 9.1.21<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. The <strong>geometric mean</strong> of non-negative real numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, ..., x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>n</mi></mroot><mo>=</mo><mroot><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mn>2</mn></msub><mover accent="true"><mi mathvariant="normal">.</mi><mo>˙</mo></mover><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mi>n</mi></msub></mrow><mi>n</mi></mroot></mrow><annotation encoding="application/x-tex">\sqrt[n]{\prod_{i=1}^{n}x_i} = \sqrt[n]{x_1 \dot x_2 \dot ... \dot x_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.302709em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5960291999999999em;"><span style="top:-2.8807492em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.937291em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.897291em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width="400em" height="1.28em" viewbox="0 0 400000 1296" preserveaspectratio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.302709em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.19606999999999997em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6039960000000001em;"><span style="top:-2.888716em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8439300000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.11111000000000001em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">.</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.13889em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.11111000000000001em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.8039300000000003em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19606999999999997em;"><span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>Theorem 9.1.22 (Inequality of arithmetic and geometric means)<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">n \in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_1, x_2, ..., x_n \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. Then<br>
<span class="katex-error" title="ParseError: KaTeX parse error: Got function &#039;\dot&#039; with no arguments as argument to &#039;\dot&#039; at position 19: …rt[n]{x_1 \dot \̲d̲o̲t̲ ̲\dot x_n} \le \…">\sqrt[n]{x_1 \dot \dot \dot x_n} \le \frac{x_1 + ... + x_n}{n}</span><br>
with equality if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1 = ... = x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>Theorem 9.1.31 (Inequality of geometric and harmonic means)<br>
let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">n \in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_1, x_2, ..., x_n \gt 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. Then<br>
<span class="katex-error" title="ParseError: KaTeX parse error: Got function &#039;\dot&#039; with no arguments as argument to &#039;\dot&#039; at position 86: …n]{x_1x_2 \dot \̲d̲o̲t̲ ̲\dot x_n}">\frac{n}{\frac{1}{x_1} + frac{1}{x_2} + ... + frac{1}{x_n}} \le \sqrt[n]{x_1x_2 \dot \dot \dot x_n}</span></p>
</li>
<li>
<p>Theorem 9.1.34 (Inequality of quadratic and arithmetic means)<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \gt 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_1, x_2, ..., x_n \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. Then<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mi>n</mi></mfrac><mo>≤</mo><msqrt><mfrac><mrow><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow><mi>n</mi></mfrac></msqrt></mrow><annotation encoding="application/x-tex">\frac{x_1 + ... + x_n}{n} \le \sqrt{\frac{x_1^2 + x_2^2 + ... + x_n^2}{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1634309999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184309999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.4816800000000001em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.35832em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.09164em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.52806em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051142857142857em;"><span style="top:-2.188485714285714em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span><span style="top:-2.8448em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.31151428571428574em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051142857142857em;"><span style="top:-2.188485714285714em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span><span style="top:-2.8448em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.31151428571428574em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.214em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.31832em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width="400em" height="1.8800000000000001em" viewbox="0 0 400000 1944" preserveaspectratio="xMinYMin slice"><path d="M983 90
l0 -0
c4,-6.7,10,-10,18,-10 H400000v40
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4816800000000001em;"><span></span></span></span></span></span></span></span></span><br>
with equality if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1 = ... = x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Get deeper in SRAM</title>
    <url>/posts/5a6cf88d.html</url>
    <content><![CDATA[<h2 id="theory">Theory</h2>
<p>RAM(Random Access Memory)具有如下两个特点：</p>
<ul>
<li>易变，断电时易失数据。</li>
<li>读写行为快，速度与数据存储位置无关。</li>
</ul>
<p>RAM又有如下两个分类：</p>
<ul>
<li>DRAM (Dynamic Random Access Memory)</li>
<li>SRAM (Static Random Access Memory)</li>
</ul>
<p>DRAM由一个电容器(capacitor)和一个晶体管(transistor)构成。因为电容器的缺陷，DRAM经常需要被刷新，因此DRAM要远比SRAM慢。</p>
<p>因此SRAM经常被用作缓存(cache)，而DRAM因为相对便宜且密度大主要作为处理器内存。</p>
<p>一个SRAM中有六个晶体管，可以存储一个bit的数据，每个bit存储在四个晶体管上，因此有两个重合部分。</p>
<p>SRAM小结：</p>
<ul>
<li>最快的存储器</li>
<li>由6个晶体管构成</li>
<li>不需要被刷新</li>
<li>密度更低，平方面积存储能力更差，因为一个单元上的电路更多</li>
</ul>
<p>文章主要讨论异步(asynchronous) SRAM。</p>
<h2 id="hands-on">Hands On</h2>
<p>Cmod A7 开发板集成了SRAM，其特点如下：</p>
<ul>
<li>512KB</li>
<li>19个地址信号</li>
<li>8个双向数据信号</li>
<li>3个控制信号
<ul>
<li>三个控制信号分别是CE，OE和WE，活跃度都很低</li>
<li>ce_n (chip enable)：控制芯片是否被启用</li>
<li>we_n (write enable): 控制写入操作</li>
<li>oe_n (output enable): 控制读出操作</li>
</ul>
</li>
<li>访问时间10ns</li>
<li>数据总线(data bus)为8 bit宽</li>
</ul>
<p>开发板的读操作涉及到11个时间参数，其中的6个如下：</p>
<ul>
<li>trc：读周期时间(read cycle time)，两个读操作的最短间隔，几乎与tAA相等。</li>
<li>tAA：地址访问时间(address access time)，地址变化后获取稳定数据的时间。</li>
<li>tOHA：输出保持时间(output hold time)，地址变化后输出数据仍然有效的时间。</li>
<li>tDOE：输出使能访问时间(output enable access time)，激活oen后获取有效数据所需的时间。</li>
<li>tHZOE：输出使能到high-Z时间(output enable to high-Z time)，oe_n去激活后三态缓冲器进入高阻抗状态的时间。</li>
<li>tLZOE：输出使能到low-Z时间(output enable to low-Z time)，oe_n被激活后三态缓冲器离开高阻抗状态的时间。请注意，即使输出不再处于高阻抗状态，数据仍然无效。</li>
</ul>
<p>开发板的写操作涉及到的时间参数如下：</p>
<ul>
<li>twc：写周期时间(write cycle time)，两个写操作的最短间隔。</li>
<li>tSA：地址建立时间(address setup time)，在we_n被激活之前，地址必须稳定的最短时间。</li>
<li>tHA：地址保持时间(address hold time)，去激活we_n后地址必须稳定的最短时间。</li>
<li>tPWE1：写使能脉冲宽度(we_n pulse width)，we_n必须断言的最小时间。</li>
<li>tso：数据建立时间(data setup time)，在锁存沿(we_n从0移动到1的上升沿)之前，数据必须保持稳定的最短时间。</li>
<li>tHD：数据保持时间，数据在锁存沿后必须保持稳定的最短时间。</li>
</ul>
<h2 id="controller">Controller</h2>
<p>为了成功执行一个读或写操作，断言地址、数据和控制信号的顺序是很重要的，并且需要确定他们保持一段时间的稳定。为了实现这些并且接入SRAM，我们用一个存储控制器(Memory Controller)。</p>
<h3 id="controller-using-verilog">Controller using Verilog</h3>
<p>一个非常简单和基本的SRAM控制器的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module basic_sram_controller(</span><br><span class="line"></span><br><span class="line">  input wire clk,                        //  Clock signal</span><br><span class="line"></span><br><span class="line">  input wire rw,                         //  With this signal, we select reading or writing operation</span><br><span class="line">  input wire [18:0] addr,                //  Address bus</span><br><span class="line">  input wire [7:0] data_f2s,             //  Data to be writteb in the SRAM</span><br><span class="line">  </span><br><span class="line">  output reg [7:0] data_s2f_r,           //  It is the 8-bit registered data retrieved from the SRAM (the -s2f suffix stands for SRAM to FPGA)</span><br><span class="line">  output wire [18:0] ad,                 //  Address bus</span><br><span class="line">  output wire we_n,                      //  Write enable (active-low)</span><br><span class="line">  output wire oe_n,                      //  Output enable (active-low)</span><br><span class="line"></span><br><span class="line">  inout wire [7:0] dio_a,                //  Data bus</span><br><span class="line">  output wire ce_a_n                     //  Chip enable (active-low). Disables or enables the chip.</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assign ce_a_n = 1&#x27;b0;</span><br><span class="line">  assign oe_n = 1&#x27;b0;</span><br><span class="line">  assign we_n = rw;</span><br><span class="line">  assign ad = addr;</span><br><span class="line">  </span><br><span class="line">  assign dio_a = (rw == 1&#x27;b1)? 8&#x27;hZZ : data_f2s;</span><br><span class="line">  </span><br><span class="line">  always @(posedge clk) begin</span><br><span class="line">    if (rw == 1&#x27;b1)</span><br><span class="line">      data_s2f_r &lt;= dio_a;</span><br><span class="line">  end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p>这种设计提供了较大的时间裕度，并且不施加任何严格的时间限制。它已在Cmod A7 FPGA板上进行了测试，该板具有12 MHz时钟输入，即周期为83.333纳秒。</p>
<p>ce_n(芯片使能信号)和oe_n(输出使能信号)一直处于激活状态。</p>
<p>我们对三态缓冲区使用三元运算符。注意，dio是一个双向总线。</p>
<p>下面是一个非常简单的仿真模型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">specify					</span><br><span class="line">    specparam </span><br><span class="line">    Twp = 8,	</span><br><span class="line">    Tdw = 6,				</span><br><span class="line">    Tdh = 0;				</span><br><span class="line">    $width (negedge we_n, Twp);			</span><br><span class="line">    $setup (data, posedge we_n, Tdw);	</span><br><span class="line">    $hold (posedge we_n, data, Tdh);	</span><br><span class="line">endspecify</span><br><span class="line">reg [7:0] sram [0:1024];</span><br><span class="line">always@(posedge we_n)</span><br><span class="line">    if (ce_n == 1&#x27;b0)  </span><br><span class="line">    sram[addr] &lt;= data;</span><br><span class="line">assign #10 data = (~ce_n &amp; ~oe_n) ? sram[addr] :  8&#x27;bz; </span><br></pre></td></tr></table></figure>
<p>接下来要构建一个可综合的设计来测试SRAM。对于测试SRAM的HDL设计，我们必须能够在任何特定地址中写入和读取任何数据。因此，重要的是要有一个终端来选择我们想要进行的操作，并输入任何所需的数据。要做到这一点，设计将需要以下模块:</p>
<ul>
<li>UART：向FPGA/PC发送或接受数据。</li>
<li>Debouncer：debounce reset button。</li>
<li>FSM: 控制设计中所有的信号和状态。</li>
<li>SRAM控制器</li>
</ul>
<p>原文章：<a href="https://www.hackster.io/salvador-canas/a-practical-introduction-to-sram-memories-using-an-fpga-i-3f3992">https://www.hackster.io/salvador-canas/a-practical-introduction-to-sram-memories-using-an-fpga-i-3f3992</a></p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Wrap-up post</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU 21127：Summary Sheet of Strategy in Chapter 3-6</title>
    <url>/posts/cmu21127note3.html</url>
    <content><![CDATA[<ol>
<li>
<p>Strategy 3.1.5 (Proving two functions are equal)<br>
Given functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f, g: X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> with the same domain and codomain, in order to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f=g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>, it suffices to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)=g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>.</p>
</li>
<li>
<p>Strategy 3.1.27 (Proving set identities using characteristic functions)<br>
In order to prove that two subsets U and V of a set X are eq    ual, it suffices to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>χ</mi><mi>U</mi></msub><mo>=</mo><msub><mi>χ</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">\chi_{U} = \chi_{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">χ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">χ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
</li>
<li>
<p>Strategy 3.2.2 (Proving a function is injective)<br>
In order to prove that a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f: X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is injective, it suffices to fix, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a, b \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, assume that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a) = f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>, and then derive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>.<br>
s</p>
</li>
<li>
<p>Strategy 3.2.10 (Proving a function is surjective)<br>
To prove that a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f: X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is surjective, it suffices to take an aribitrary element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">y \in Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> and, in terms of y, find an element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>.<br>
In order to fiind x, it is often useful to start from the equation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> and derive some possible values of x. But be careful——in order to complete the proof, it is necessary to verify that the equation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> istrue for the chosen value of x.</p>
</li>
<li>
<p>Strategy 3.2.10.5 (Proving a function is bijective)<br>
To prove that a function f is bijective, prove that it is injective and surjective.</p>
</li>
<li>
<p>Strategy 3.2.26 (Proving a functio is injective by finding a left inverse)<br>
In order to prove that a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f: X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is injective, it suffices to find a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">g: Y \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">g(f(x)) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>.</p>
</li>
<li>
<p>Strategy 3.2.32 (Proving a function is surjective by finding a right inverse)<br>
In order to prove that a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f: X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is surjective, it suffices to find a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">g: Y \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(g(y)) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">y \in Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>.</p>
</li>
<li>
<p>Strategy 4.1.3 (Definition by recursion)<br>
In order to specify a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N} \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, it suffices to define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> and, for given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">n \in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>, assume that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> has been defined, and define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(s(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> in terms of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> is the successor function.</p>
</li>
<li>
<p>Strategy 4.2.2 (Proof by (weak) induction)<br>
In order to prove a proposition of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall n \ge n_0,p(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord">∀</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, it suffices to prove that:</p>
</li>
</ol>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is true, and</li>
<li>For all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n \ge n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> is true, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> is true.<br>
Some terminology has evolved for proofs by induction:</li>
<li>The proof of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is called the <strong>base case</strong>.</li>
<li>The proof of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>→</mo><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall n \ge n_0, (p(n) \rightarrow p(n+1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord">∀</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> is called the <strong>induction step</strong>.</li>
<li>In the induction step, the assumption <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> is called the <strong>induction hypothesis</strong>;</li>
<li>In the induction step, the proposition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> is called the <strong>induction goal</strong>.</li>
</ul>
<ol start="10">
<li>Strategy 4.3.3 (Proof by strong induction)<br>
In order to prove a proposition of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall n \ge n_0, p(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord">∀</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, it suffices to prove that:</li>
</ol>
<ul>
<li>(<strong>Base case</strong>) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is true; and</li>
<li>(<strong>Inductio step</strong>) For all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n \ge n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> is true for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n_0 \le k \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> is true.</li>
</ul>
<ol start="11">
<li>Strategy 4.3.6 (Proof by strong induction with multiple base cases)<br>
In order to prove a statement of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall n \ge n_0, p(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord">∀</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, it suffices to prove that:</li>
</ol>
<ul>
<li>(<strong>Base cases</strong>) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mrow><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>n</mi><mn>1</mn></msub></mrow></mrow><annotation encoding="application/x-tex">k \in {n_0, n_0 + 1, ..., n_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>&gt;</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_1 \gt n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>; and</li>
<li>(<strong>Induction step</strong>) For all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n \ge n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> is true for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n_0 \le k \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, then $$p(n+1)$$ is true.</li>
</ul>
<ol start="12">
<li>
<p>Strategy 6.1.2 (Proving that a set is finite)<br>
In order to prove that a set X is finite, it suffices to find a bijection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">[n] \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">n \in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>.</p>
</li>
<li>
<p>Strategy 6.1.16 (Comparing the sizes of finite sets)<br>
Let X and Y be finite sets.</p>
</li>
</ol>
<p>(a) In order to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>≤</mo><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[X] \le [Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span>, it suffices to find an injection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>.<br>
(b) In order to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>≥</mo><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[X] \ge [Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span>, it suffices to find a surjection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>.<br>
© In order to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[X] = [Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span>, it suffices to find a bijection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>.</p>
<p>Strategy © is commonly known as <strong>bijective proof</strong>.</p>
<ol start="14">
<li>
<p>Strategy 6.2.18(Cantor’s diagonal argument)<br>
In order to prove that a set X is uncountable, it suffices to prove that no function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N} \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> is surjective using the following argument: given a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N} \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, find an element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">b \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> that “disagrees” with each value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> about some statement involving n.</p>
</li>
<li>
<p>Proposition (Helpful to Prove Supremums)<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊂</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">A \subset R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">m \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> be an upper bound of A, we have<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>p</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>↔</mo><mi mathvariant="normal">∀</mi><mi>ϵ</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi><mo separator="true">,</mo><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn><mo>→</mo><mo stretchy="false">[</mo><mi mathvariant="normal">∃</mi><mi>a</mi><mo>∈</mo><mi>A</mi><mo separator="true">,</mo><mi>a</mi><mo>&gt;</mo><mi>m</mi><mo>−</mo><mi>ϵ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">m = sup(A) \leftrightarrow \forall \epsilon \in \mathbb{R}, \epsilon &gt; 0 \rightarrow[\exists a \in A, a &gt; m - \epsilon ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">∃</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϵ</span><span class="mclose">]</span></span></span></span></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>IB Computer Science： 伪代码、流程图和简单算法小记</title>
    <url>/posts/68e9188a.html</url>
    <content><![CDATA[<!-- 事先声明，我并不认同IB的垃圾计算机教学大纲和它规定的垃圾标准，将下列内容整理在博客中只是为了苟住校内成绩做出的无奈妥协。 -->
<p>伪代码编写练习可以使用网站：<a href="http://ibcomp.fis.edu/pseudocode/pcode.html">http://ibcomp.fis.edu/pseudocode/pcode.html</a></p>
<h2 id="伪代码语法">伪代码语法</h2>
<h3 id="循环逻辑：">循环逻辑：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop i from ... to ...</span><br><span class="line">    TODO()</span><br><span class="line">end loop</span><br><span class="line"></span><br><span class="line">loop while (condition?)</span><br><span class="line">    TODO()</span><br><span class="line">end loop</span><br></pre></td></tr></table></figure>
<h3 id="分支逻辑：">分支逻辑：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (condition?) then</span><br><span class="line">    TODO()</span><br><span class="line">else if (condition?) then</span><br><span class="line">    TODO()</span><br><span class="line">else</span><br><span class="line">    TODO()</span><br><span class="line">end if</span><br></pre></td></tr></table></figure>
<h3 id="数组管理：">数组管理：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr = new array()                     // set a new array</span><br><span class="line">arr = [..., ..., ...]                 //set values for the array</span><br><span class="line">arr[...]                              //returns the value of a certain index</span><br><span class="line">arr.Length()                          //returns the length of an array(for some reason this could not run on the above website)</span><br></pre></td></tr></table></figure>
<h3 id="集合管理：">集合管理：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">coll = new collection()               //set a new collection</span><br><span class="line">coll.addItem(certain things)          //add something to the collection</span><br><span class="line">coll.getNext()                        //return the next value</span><br><span class="line">coll.resetNext()                      //go back to the start of the collection</span><br><span class="line">coll.hasNext()                        //returns a boolean value that indicates whether it has next item or not</span><br><span class="line">coll.isEmpty()                        //returns a boolean value that indicates whether the collection is empty or not</span><br></pre></td></tr></table></figure>
<h3 id="栈管理：">栈管理：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// One thing to be remember, first in last out</span><br><span class="line">stack = new stack()                   //set a new stack</span><br><span class="line">stack.push(certain things)            //push an item into the stack</span><br><span class="line">stack.pop()                           //returns the last item of the stack</span><br><span class="line">stack.isEmpty()                       //returns a boolean value that indicates whether the stack is empty or not</span><br></pre></td></tr></table></figure>
<h3 id="队列管理：">队列管理：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Another thing to remember, first in first out</span><br><span class="line">queue = new queue()                   //set a new queue</span><br><span class="line">queue.enqueue(certain things)         //put an item to the end of the queue</span><br><span class="line">queue.dequeue()                       //delete and return the front item of the queue</span><br><span class="line">queue.isEmpty()                       //returns a boolean value that indicates whether the queue is empty or not</span><br></pre></td></tr></table></figure>
<h2 id="流程图画法">流程图画法</h2>
<p><img src="/posts/68e9188a.htm/Screenshot%202023-09-20%20182101.png" alt></p>
<p>Then use arrows to link the blocks.</p>
<h2 id="简单代码的伪代码实现">简单代码的伪代码实现</h2>
<p>The following codes are all based on arrays. Searching/Sorting other form of data set need to do simple modifications to the code.</p>
<h3 id="sequential-search">Sequential Search</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr = [5, 6, 3, 4, 2, 7, 8, 1]</span><br><span class="line"></span><br><span class="line">loop i from 0 to 7</span><br><span class="line">   if (arr[i] == 2) then</span><br><span class="line">      index = i</span><br><span class="line">   end if</span><br><span class="line">end loop</span><br><span class="line"></span><br><span class="line">output &quot;The index of number 2 is: &quot;, index</span><br></pre></td></tr></table></figure>
<h3 id="binary-search">Binary Search</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr = [5, 6, 3, 4, 2, 7, 8, 1]</span><br><span class="line"></span><br><span class="line">loop i from 0 to 6</span><br><span class="line">   min_idx = i</span><br><span class="line">   loop j from i+1 to 7</span><br><span class="line">      if arr[j] &lt; arr[min_idx] then</span><br><span class="line">         min_idx = j</span><br><span class="line">      end if</span><br><span class="line">   end loop</span><br><span class="line">   if NOT(min_idx == i) then</span><br><span class="line">      TEMP = arr[min_idx]</span><br><span class="line">      arr[min_idx] = arr[i]</span><br><span class="line">      arr[i] = TEMP</span><br><span class="line">   end if</span><br><span class="line">end loop</span><br><span class="line">//Sort the array first since binary search is only applicable in ordered series</span><br><span class="line"></span><br><span class="line">low = 0</span><br><span class="line">high = 7</span><br><span class="line">found = -1</span><br><span class="line">loop while found = -1 AND low &lt;= high</span><br><span class="line">   mid = div(low + high, 2)</span><br><span class="line">   if (arr[mid] = 8) then</span><br><span class="line">      found = mid</span><br><span class="line">   else if (arr[mid] &lt; 8) then</span><br><span class="line">      low = mid + 1</span><br><span class="line">   else</span><br><span class="line">      high = mid - 1 </span><br><span class="line">   end if</span><br><span class="line">end loop</span><br><span class="line"></span><br><span class="line">if found &gt;= 0 then</span><br><span class="line">   output &quot;The index of number 8 is: &quot;, found</span><br><span class="line">else</span><br><span class="line">   output &quot;Number was not found&quot;</span><br><span class="line">end if</span><br></pre></td></tr></table></figure>
<h3 id="bubble-sort">Bubble Sort</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr = [5, 6, 3, 4, 2, 7, 8, 1]</span><br><span class="line"></span><br><span class="line">loop i from 0 to 6</span><br><span class="line">   loop j from 0 to 6-i</span><br><span class="line">      if arr[j] &gt; arr[j+1] then</span><br><span class="line">         TEMP = arr[j+1]</span><br><span class="line">         arr[j+1] = arr[j]</span><br><span class="line">         arr[j] = TEMP</span><br><span class="line">      end if</span><br><span class="line">   end loop </span><br><span class="line">end loop</span><br><span class="line"> </span><br><span class="line">loop i from 0 to 7</span><br><span class="line">   output arr[i]</span><br><span class="line">end loop</span><br></pre></td></tr></table></figure>
<h3 id="selection-sort">Selection Sort</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr = [5, 6, 3, 4, 2, 7, 8, 1]</span><br><span class="line">loop i from 0 to 6</span><br><span class="line">   min_idx = i</span><br><span class="line">   loop j from i+1 to 7</span><br><span class="line">      if arr[j] &lt; arr[min_idx] then</span><br><span class="line">         min_idx = j</span><br><span class="line">      end if</span><br><span class="line">   end loop</span><br><span class="line">   if NOT(min_idx == i) then</span><br><span class="line">      TEMP = arr[min_idx]</span><br><span class="line">      arr[min_idx] = arr[i]</span><br><span class="line">      arr[i] = TEMP</span><br><span class="line">   end if</span><br><span class="line">end loop</span><br><span class="line"></span><br><span class="line">loop i from 0 to 7</span><br><span class="line">   output arr[i]</span><br><span class="line">end loop</span><br></pre></td></tr></table></figure>
<h2 id="简单算法的流程图实现">简单算法的流程图实现</h2>
<h3 id="sequential-search">Sequential Search</h3>
<p><img src="/posts/68e9188a.htm/SS.jpg" alt></p>
<h3 id="binary-search">Binary Search</h3>
<p><img src="/posts/68e9188a.htm/BS.jpg" alt></p>
<h3 id="bubble-sort">Bubble Sort</h3>
<p><img src="/posts/68e9188a.htm/BubS.jpg" alt></p>
<h3 id="selection-sort">Selection Sort</h3>
<p><img src="/posts/68e9188a.htm/SelS.jpg" alt></p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU ICS：PA(Programming Assignment) 1 思路总结</title>
    <url>/posts/2e23f8c2.html</url>
    <content><![CDATA[<p>在此对PA1实验中的任务进行思路上的总结。</p>
<h1 id="框架代码理解">框架代码理解</h1>
<pre><code>nemu
</code></pre>
<p>├── configs                    # 预先提供的一些配置文件<br>
├── include                    # 存放全局使用的头文件<br>
│   ├── common.h               # 公用的头文件<br>
│   ├── config                 # 配置系统生成的头文件, 用于维护配置选项更新的时间戳<br>
│   ├── cpu<br>
│   │   ├── cpu.h<br>
│   │   ├── decode.h           # 译码相关<br>
│   │   ├── difftest.h<br>
│   │   └── ifetch.h           # 取指相关<br>
│   ├── debug.h                # 一些方便调试用的宏<br>
│   ├── device                 # 设备相关<br>
│   ├── difftest-def.h<br>
│   ├── generated<br>
│   │   └── autoconf.h         # 配置系统生成的头文件, 用于根据配置信息定义相关的宏<br>
│   ├── isa.h                  # ISA相关<br>
│   ├── macro.h                # 一些方便的宏定义<br>
│   ├── memory                 # 访问内存相关<br>
│   └── utils.h<br>
├── Kconfig                    # 配置信息管理的规则<br>
├── Makefile                   # Makefile构建脚本<br>
├── <a href="http://README.md">README.md</a><br>
├── resource                   # 一些辅助资源<br>
├── scripts                    # Makefile构建脚本<br>
│   ├── <a href="http://build.mk">build.mk</a><br>
│   ├── <a href="http://config.mk">config.mk</a><br>
│   ├── <a href="http://git.mk">git.mk</a>                 # git版本控制相关<br>
│   └── <a href="http://native.mk">native.mk</a><br>
├── src                        # 源文件<br>
│   ├── cpu<br>
│   │   └── cpu-exec.c         # 指令执行的主循环<br>
│   ├── device                 # 设备相关<br>
│   ├── engine<br>
│   │   └── interpreter        # 解释器的实现<br>
│   ├── <a href="http://filelist.mk">filelist.mk</a><br>
│   ├── isa                    # ISA相关的实现<br>
│   │   ├── mips32<br>
│   │   ├── riscv32<br>
│   │   ├── riscv64<br>
│   │   └── x86<br>
│   ├── memory                 # 内存访问的实现<br>
│   ├── monitor<br>
│   │   ├── monitor.c<br>
│   │   └── sdb                # 简易调试器<br>
│   │       ├── expr.c         # 表达式求值的实现<br>
│   │       ├── sdb.c          # 简易调试器的命令处理<br>
│   │       └── watchpoint.c   # 监视点的实现<br>
│   ├── nemu-main.c            # 你知道的…<br>
│   └── utils                  # 一些公共的功能<br>
│       ├── log.c              # 日志文件相关<br>
│       ├── rand.c<br>
│       ├── state.c<br>
│       └── timer.c<br>
└── tools                      # 一些工具<br>
├── fixdep                 # 依赖修复, 配合配置系统进行使用<br>
├── gen-expr<br>
├── kconfig                # 配置系统<br>
├── kvm-diff<br>
├── qemu-diff<br>
└── spike-diff</p>
<h1 id="顺利的运行">顺利的运行</h1>
<ol>
<li>Remove Assert(0)：<br>
根据报错信息将monitor.c中对应的assert语句移除即可。</li>
<li>优美的退出：<br>
因为是退出NEMU时报错，所以首先在NEMU的main.c中找报错原因，发现最后返回了is_exit_status_bad()这一函数。转到定义后发现默认返回值是1，根据函数的具体内容对sdb.c中的cmd_q函数进行调整后问题顺利解决。</li>
</ol>
<h1 id="pa1-1-基础设施">PA1.1 基础设施</h1>
<h2 id="pa1-1-1-单步执行">PA1.1.1 单步执行</h2>
<p>根据讲义中的提示，单步执行要求我们实现si命令，并且根据si命令后面的argument执行具体步数。讲义在RTFSC中提到cpu-exec.c模拟了CPU运行，转到其中能够轻易发现相关函数，只需要传入对应参数就可以实现要求的功能。于是在sdb.c中实现了相应的cmd_si函数，值得一提的是用sscanf将指针args转化为了可以使用的变量。</p>
<h2 id="pa1-1-2-打印寄存器">PA1.1.2 打印寄存器</h2>
<p>要求我们实现info r打印32个寄存器的值。根据提供的API文档可以发现有关寄存器的定义在isa-reg.h中，RTFSC后发现寄存器的值是gpr表示，于是在reg.c中实现了对应的API，即isa_reg_display()。然后在sdb.c中实现对应的命令。值得一提的是cmd_info在后续实现监视点的时候还会用到。</p>
<h2 id="pa1-1-3-扫描内存">PA1.1.3 扫描内存</h2>
<p>要求我们实现info x，给定指定的其实内存和要打印的内存个数，输出内存数据。根据RTFSC中的提示在vaddr.c中找到了相应读取内存的函数vaddr_read()，然后在sdb.c中通过循环实现具体指令，并且设定打印内存长度为4。</p>
<h1 id="pa1-2-表达式求值">PA1.2 表达式求值</h1>
<h2 id="pa1-2-1-词法分析">PA1.2.1 词法分析</h2>
<p>在表达式求值中只允许出现的token类型有十进制整数，加减乘除，括号和空格串。expr.c中的enum编写了用于识别这些token的类型，具体识别规则见“正则表达式速览”。同一文件中的init_regex()函数会将这些规则编译成被库函数使用的pattern匹配信息，如果正则表达式语法有问题会触发assertion fail。<br>
make_token()函数用于识别表达式中的token，用position来表示当前处理的位置，按照顺序用不同的规则匹配当前位置的字符串，如果匹配成功log()则会输出识别成功的token类型，后面通过nr_token指示已经被识别出的token数目为当前正在处理到的token赋值，其中加减乘除此类只需要记录token类型，而数字则还需要记录token的具体内容，这个用substr_start和substr_len进行具体内容的赋值。</p>
<h2 id="pa1-2-2-递归求值">PA1.2.2 递归求值</h2>
<p>首先在sdb.c中实现cmd_p的指令，跳转到expr.c中的expr函数，再对expr函数进行具体编写，为了方便我重新写了一个新函数并在expr()中调用。新求值函数eval首先判断token的首位，eval的递归采用两个位置变量p和q来表示正在处理的token位置。如果末位token的位置p小于首位token的位置q则判断表达式不合法；如果p等于q则说明递归到了某一个具体的数字，这个时候要对该单一token进行类型判断，如果不是数字类型则输出报错信息，反之直接返回数字的值。值得注意的是此处不能直接返回tokens结构体中的str部分，应使用strtol将token的具体内容转换成十进制整数后再返回。</p>
<p>如果p &lt; q则先进行括号判断，此处我又调用了自己写的check_parentheses()函数。函数结构非常简单，如果此时的位置变量p和q代表的首位token和末位token分别是正括号和反括号，则开始正式判断。使用一个计数变量cnt来表示当前括号的个数，如果是正括号则加一，反括号则减一。当cnt为零时判断当前处理的token是否是末尾token，以此确定首位token和末尾token的正反括号是成对的。因为首位是正括号且末位是反括号的情况有两种：(…+…)+(…+…)和(…+(…+…))，前者实际上并不需要check_parentheses，因为主运算符仍然在括号外面。因此如果首位和末位括号成对则返回true。最后如果cnt不为零的话返回false。在eval()中如果check_parentheses()返回值为真，那么将p设为p+1，q设为q-1进行下一层的递归。</p>
<p>如果上面三个条件都没有满足则进行主运算符的判断，在此又要调用自己写的find_major()函数。讲义中提到了主运算符的几个特点：主运算符一定是运算符(某种意义上来说是句废话)、出现在一对括号中的token不是主运算符、主运算符的优先级在表达式中是最低的、当有多个运算符的优先级都是最低时最后被结合的运算符才是主运算符。根据这几条规则我们就可以进行具体函数的编写，首先是定义计数变量cnt、用于指示当前运算符优先级的op_type和主运算符的位置变量position，我们用for循环进行p和q之间主运算符的判断。如果判断过程中遇到数字类型的token则直接跳过(根据第一条规则)，遇到正反括号则仿照check_parentheses中的思路利用cnt进行判断。如果是正括号则cnt++。是反括号则cnt–，并且判断cnt是否为零，如果是零的话find_major()直接返回-1，因为表达式不合法。在反括号的情况下判断是因为此情况下cnt为零只有两种情况：缺少了一个正括号或者多了一个反括号。比在正括号的情况下判断更加方便。如果cnt&gt;0则continue。然后进行运算符的判断，这里新建一个比较变量tmp_type，初始值为零，根据运算符类型赋值，加减赋2，乘除为1(因为在表达式中运算符的优先级越低越可能成为主运算符，所以在这里优先级更高的被赋的值反而更低)。最后进行op_type和tmp_type的判断，如果tmp_type大于op_type则将其赋值给op_type，并且记录此时的位置。如果tmp_type等于op_type同样将其赋值给op_type(根据第四条规则)。循环结束后先进行cnt的判断，然后返回position变量。</p>
<p>找完主运算符后就可以进行具体值的计算，设主运算符左边的变量为val1，右边为val2，继续递归，直到递归到 <expr> (±*/) <expr>，这是val1和val2递归的结果是其本身。用switch case进行运算符类型的判断，然后返回运算结果，这里除法要特殊注意val2不能为零。</expr></expr></p>
<p>等到eval()函数计算完表达式的值后expr()函数就会接收到其返回的值，expr()函数会直接将收到的值返回到sdb.c中的cmd_p()，然后输出到屏幕上。</p>
<h1 id="pa1-3-监视点">PA1.3 监视点</h1>
<h2 id="pa-1-3-1-拓展表达式求值">PA 1.3.1 拓展表达式求值</h2>
<p>拓展表达式求值新增了十六进制数、负数、打印寄存器、指针解引用和与或非、等于、不等于、大于、小于、大于等于、小于等于运算。与运算、或运算、等于、不等于、大于、小于、大于等于、小于等于的实现逻辑很简单。先编写匹配规则和make_token()，然后在find_major()中增加计算优先级，这些运算的优先级都是最低的，所以在find_major()中的匹配优先度度最高。最后在eval()函数中增加case计算即可。</p>
<p>真正麻烦的是十六进制数，打印寄存器，指针解引用，负数和非运算。其中负数和指针解引用还要更加麻烦，所以先阐释其他运算的实现。在这里我识别十六进制数的思路是匹配0x，并且在TK_NUM的匹配规则中加A-F，如此就可以将0x是为一个一元运算符进行处理，这里要注意0x的匹配规则要高于TK_NUM的匹配规则，否则就会出现只能匹配到0而不能匹配到x的问题。识别完成后正常编写make_token()。然后在find_major()中编写优先级，一元运算符的计算优先级都是最高的，所以在find_major()中赋最低的值。最后在eval()中返回十进制的值，这里我调用了自己写的一个进制转换函数。主要思路就是按位取余，然后乘以该位的位权，累加到Dec变量中，也就是最后的十进制结果。至此十六进制数的实现已经完成。</p>
<p>然后是打印寄存器，仿照十六进制数的思路进行处理，一直到eval()函数部分，这里要返回的值就是cpu.gpr[i]。非运算同理，eval()函数部分返回的值是!val2。</p>
<p>负数和指针解引用实际上使用的符号都是&quot; - “或” * “，所以在make_token()阶段并不能将其和减法和乘法区分开来。所以我们编写特殊的check_unary()函数来检验。check_unary()函数应该放在expr()函数的make_token()后面。其主要思路就是判定当前处理的token类型是不是” * “或” - &quot;，如果是的话进行进一步判断，如果token编号是0则证明该运算符是表达式的第一个，直接将其token类型修改为负数或者指针解引用(注意这里必须要这么判断，如果全部使用后面那条规则判断的话会产生结构体访问越界)，如果token编号不为零的话就判断前一个token的类型是不是数字或者反括号，如果不是的话证明运算符是一元运算符，则将token类型修改为负数或者指针解引用。然后仿照之前对一元运算符的处理即可，eval()函数中负数类型直接返回-value，指针解引用类型则仿照PA 1.1.3进行处理即可。</p>
<h2 id="pa-1-3-2-监视点的管理">PA 1.3.2 监视点的管理</h2>
<p>开始之前要为监视点结构体新增两个变量，一个是char *类型的expr和int类型的value。</p>
<p>监视点的管理包括新建监视点new_wp()和删除监视点free_wp()。在new_wp()中首先要判断监视点池是否为空，然后建立一个新的监视点结构体，将空闲监视点赋值给新建立的结构体，然后将空闲监视点向后移动一位，将head(正在处理的监视点)设定为新建立的监视点。</p>
<p>在free_wp()中首先判断要删除的监视点是不是head，如果是的话就直接将head设为NULL。新建一个监视点结构体flag，将其设为监视点池的第一个监视点，也就是监视点0，一个一个往后推，直到推到要删除的监视点的前一个监视点，将flag的下一个设为要删除的监视点的下一个，也就是暂时将要删除的监视点抽出监视点池。</p>
<h2 id="pa-1-3-3-监视点功能的实现">PA 1.3.3 监视点功能的实现</h2>
<p>首先还是在sdb.c中编写相关的指令(info w、cmd_w、cmd_d)。info w的实现很简单，就是新增一个条件判断，如果输入为w的话调用display_wp()函数(具体函数一会在watchpoint.c中实现)。</p>
<p>然后编写cmd_w指令，相关细节仿照PA1，将要计算的表达式读入并调用expr()计算，将计算结果赋值给result变量，再将表达式和result传给set_wp()函数(同样一会在watchpoint.c中实现)。</p>
<p>cmd_d指令也仿照PA1进行编写，将要删除的监视点编号传入delete_wp()函数即可。</p>
<p>然后是watchpoint.c中监视点功能的具体实现，包括set_wp()、delete_wp()、display_wp()和check_wp()。set_wp()的实现很简单，先建立一个新的监视点结构体，将接收到的表达式用strndup函数复制到新监视点的expr部分，将result赋值给新监视点的value部分，最后输出监视点信息。delete_wp()首先判断输入编号是否小于NR_WP，这里我用assert实现。然后建立三个监视点结构体，分别是要删除的监视点，要删除的监视点的前一个监视点和要删除的监视点的后一个监视点。建立完后先输出要删除监视点的具体信息，然后将要删除的监视点传入free_wp()，因为在free_wp()函数中将要删除的监视点抽出了监视点链表，所以调用完函数后要将要删除的监视点的expr部分设为NULL，将要删除的监视点的前一个监视点只想删除的监视点，删除的监视点指向删除的监视点的后一个监视点，到这里删除监视点的操作就正式完成了。</p>
<p>下一个是display_wp()函数的编写，首先新建一个监视点结构体，将其设置为监视点池中的第一个监视点，然后用while循环(循环条件设置为新建立的监视点是否成立)打印监视点信息，在循环的最后将监视点设置为下一个监视点即可。</p>
<p>最后是check_wp()的编写，首先还是新建一个监视点结构体，将其设置为监视点池中的第一个监视点，然后用while循环处理(循环条件设置为新建的监视点不为head的下一个监视点)，在循环中调用expr()函数计算表达式的值，如果表达式的值发生变化则输出相关信息，在循环的最后将监视点设置为下一个监视点。最后将check_wp()放进cpu-exec.c的execute()中，每执行一条指令就检查一次。</p>
<h1 id="至此pa1彻底结束">至此PA1彻底结束！</h1>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU 21127：Summary Sheet of Strategy in Chapter 1-2</title>
    <url>/posts/cmu21127note2.html</url>
    <content><![CDATA[<ol>
<li>
<p>Strategy 1.1.7 (Proving conjunctions)<br>
A proof of the proposition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∧</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \wedge q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> can be obtained by tying together two proofs, one being a proof that p is true and one being a proof that q is true.</p>
</li>
<li>
<p>Strategy 1.1.9 (Assuming conjunctions)<br>
If an assumption in a proof has the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∧</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \wedge q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, then we may assume p and assume q in the proof.</p>
</li>
<li>
<p>Strategy 1.1.13 (Proving disjunctions)<br>
In order to prove a proposition of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∨</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \vee q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, it suffices to prove just one of p or q.</p>
</li>
<li>
<p>Strategy 1.1.16 (Assuming disjunctions——proof by cases)<br>
If an assumption in a proof has the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∨</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \vee q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, then we may derive a proposition r by splitting into two cases: first, derive r from the temporary assumption that p is true, and then derive r from the assumption that q is true.</p>
</li>
<li>
<p>Strategy 1.1.22 (Proving implications)<br>
In order to prove a proposition of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⇒</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \Rightarrow q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, it suffices to assume that p is true, and then derive q from that assumption.</p>
</li>
<li>
<p>Strategy 1.1.25 (Assuming implications——modus ponens)<br>
If an assumption in a proof has the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⇒</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \Rightarrow q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, and p is also assumed to be true, then we may deduce that q is true.</p>
</li>
<li>
<p>Strategy 1.1.38 (Proving negations——proof by contradiction)<br>
In order to prove a proposition p is false (that is, that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">\neg p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord">¬</span><span class="mord mathdefault">p</span></span></span></span> is true), it suffices to assume that p is true and derive a contradiction.</p>
</li>
<li>
<p>Strategy 1.1.43 (Assuming negations)<br>
If an assumption in a proof has the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">\neg p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord">¬</span><span class="mord mathdefault">p</span></span></span></span>, then any derivation of p leads to a contradiction.</p>
</li>
<li>
<p>Strategy 1.1.45 (Using the law of excluded middle)<br>
In order to prove a proposition q is true, it suffices to split into cases based on whether some other proposition p is true or false, and prove that q is true in each case.</p>
</li>
<li>
<p>Strategy 1.2.10 (Proving universally quantified statements)<br>
To prove a proposition of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall x \in X, p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>, it suffices to prove p(x) for an arbitrary element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>——in other words, prove p(x) whilst assuming nothing about the variable x other than that it is an element of X.</p>
</li>
<li>
<p>Strategy 1.2.16 (Assuming universally quantified statements)<br>
If an assumption in a proof has the form $\forall x \in X, p(x), then we may assume that p(a) is true whenever a is an element of X. $</p>
</li>
<li>
<p>Strategy 1.2.18 (Proving existentially quantified statements)<br>
To prove a proposition of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\exists x \in X, p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∃</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>, it suffices to prove p(a) for some specific element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, which should be explicitly defined.</p>
</li>
<li>
<p>Strategy 1.2.24 (Assuming existentially quantified statements)<br>
If an assumption in the proof has the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\exists x \in X, p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∃</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>, then we may introduce a new variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> and assume that p(a) is true.</p>
</li>
<li>
<p>Strategy 1.2.29 (Proving unique-existentially quantified statements)<br>
A proof of a statement of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mo stretchy="false">!</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\exists !x \in X, p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∃</span><span class="mclose">!</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>, consists of two parts:</p>
</li>
</ol>
<ul>
<li>Existence: Prove that $\exists x \in X, p(x) is true. $</li>
<li>Uniqueness: let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a, b \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> assume that p(a) and p(b) are true, and derive a = b.<br>
Alternatively, prove existence to obtain a fixed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> such that p(a) is true, and then prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>x</mi><mo>=</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\forall x \in X, [p(x) \Rightarrow x = a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>.</li>
</ul>
<ol start="15">
<li>
<p>Strategy 1.3.11 (Logical equivalence using truth tables)<br>
In order to prove that propositional formulae are logically quivalent, it suffices to show that they have identical columns in a truth table.</p>
</li>
<li>
<p>Strategy 1.3.16 (Proof by contradiction (direct version))<br>
In order to prove a proposition p is true, it suffices to assume that p is false and derive a contradiction.</p>
</li>
<li>
<p>Strategy 1.3.20 (Proof by contraposition)<br>
In order to prove a proposition of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⇒</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \Rightarrow q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, it suffices to assume that q is false and derive that p is false.</p>
</li>
<li>
<p>Strategy 1.3.29 (Proof by counterexample)<br>
To prove that a proposition of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\forall x \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, p(x) is false, it suffices to find a single element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> such that p(a) is false. The element a is called a counterexample to the proposition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\forall x \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, p(x).</p>
</li>
<li>
<p>Strategy 1.3.40 (Assuming tautologies)<br>
Let p be a proposition. Any tautology may be assumed in any proof of p.</p>
</li>
<li>
<p>Strategy 2.1.5<br>
Let X be a set and let p(x) be a logical formula with free variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>. In order to prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">a \in {x \in X | p(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>, it suffices to prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> and that p(a) is true.</p>
</li>
<li>
<p>Strategy 2.1.15 (Proving a subset containment)<br>
In order to prove that a set U is a subset of a set X, it suffices to take an arbitrary element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">a \in U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> and prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>.</p>
</li>
<li>
<p>Strategy 2.1.23 (Proof by double containment)<br>
In order to prove that a set X is equal to a set Y, it suffices to:</p>
</li>
</ol>
<ul>
<li>Prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \subseteq Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>, i.e. let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> be an arbitrary element, and derive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">a \in Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>; and then</li>
<li>Prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊇</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \supseteq Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊇</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>, i.e. let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">a \in Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> be an arbitrary element, and derive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>.<br>
We often write “(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span>)” and “(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊇</mo></mrow><annotation encoding="application/x-tex">\supseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊇</span></span></span></span>)” to indicate the direction of the containment being proved.</li>
</ul>
<ol start="23">
<li>
<p>Strategy 2.1.28 (Proving that a set is inhabited or empty)<br>
In order to prove a set X is inhabited, it suffices to exhibit an element. In order to prove a set X is empty, assume that X is inhabited——that is, that there is some element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>——and derive a contradiction.</p>
</li>
<li>
<p>General Tips:</p>
</li>
</ol>
<ul>
<li>Use parentheses to avoid confusion wien the order of operations ordere is ambiguous.</li>
<li>“if” and “only if”
<ul>
<li>only if A, then B, arrow to the right</li>
<li>if A, then B, arrow still to the right</li>
</ul>
</li>
<li>Pay attention to language that implies exists and for all, you will need to add those two quantifiers in this case, even it is not explicitly specified.</li>
<li>The sequence of quantifiers matters, define values according to the sequence.</li>
<li>In “plain english” doesn’t mean directly translate the logical formula, but find a way to express the logic it implies, usually one sentence is good.</li>
<li>Technically, you can use the handy propostions proved in class in your proof. However, since there is huge amount of trivial things you need to remember if you are actually doing this, I would recommend memorizing few definitions and theorems, which will allow you to do a quick lemma through strategies above.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(̸</mo><mi>p</mi><mo>→</mo><mo stretchy="false">(</mo><mi>q</mi><mo>∧</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>↔</mo><mi>p</mi><mo>∧</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>q̸</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi>r̸</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\not (p \rightarrow (q \wedge r)) \leftrightarrow p \wedge ((\not q) \vee (\not r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>Remember to connect each step with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">↔</span></span></span></span> or “is equivalent to” if you want to use both directional logic to claim set extensionality.</li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>节点搭建指南</title>
    <url>/posts/cb82d49a.html</url>
    <content><![CDATA[<h2 id="网络通信的基本过程">网络通信的基本过程</h2>
<p>五层基本模型：应用层、传输层、网络层、数据链路层、物理层。<br>
数据包格式：| 源MAC | 目标MAC | 源IP | 目标IP | 源端口 | 目标端口 | 数据 |<br>
访问网址时首先在本地缓存检查是否存有域名绑定的IP地址，没有的话继续检查本地host文件，然后访问电脑中配置的DNS服务器（应用层协议，发送请求）。<br>
请求传到传输层，将应用层的数据封装，源端口为404，DNS默认目标端口是53（封装端口）。继续将封装好的数据包向下传，在网络层在数据包中添加源IP和目标IP（目标IP是DNS服务器的IP）。<br>
如果电脑发现目标IP不在网段范围内，则请求网关（家庭中通常是路由器），传到数据链路层。在数据链路层继续将本机MAC地址和网关MAC地址封装到数据包中（同一局域网内的通信用MAC地址），同时在数据包后面插入一些数据做校验。<br>
这样数据包就能顺着物理层来到网卡接口，通过网线发到交换器。交换器只能解析两层的数据，通过解析数据链路层封装的MAC地址，交换器可以将数据包发送给路由器，而路由器可以解析三层数据，然后将MAC的数据头删掉。<br>
路由器之后会将数据包转发给公网上的其他路由器（因为路由器没有跟DNS服务器直接连接）。因为数据包中记录的IP地址是内网通信的，所以路由器要将内网IP和源端口放到NAT映射表中，然后将映射成公网IP和端口。更改后再传回数据链路层，再将MAC地址添加到数据包中，最后放到物理层中传给其他路由器。<br>
经过一系列传递后找到DNS服务器，源MAC地址和目标MAC地址在传递过程中会发生改变。因为DNS是应用层协议，可以解析到应用层。最后经过DNS服务器的自下而上层层解析得到希望的IP地址。之后DNS服务器会仿照上面的传输方式重新将目标IP地址重新封装成数据包，再通过物理网口传回原来的路由器。路由器再自下而上解析，自上而下封装传给交换机。交换器直接传给本地，本地再自下而上层层解析，这样电脑就可以得到目标IP地址。<br>
电脑得到目标网站的IP地址之后就可以将实际的请求重新进行打包发给目标服务器。数据封装、传输、解析、返回的流程和上面请求DNS服务器一样。值得注意的是这里的目标IP地址就变成了网站域名绑定的IP地址。<br>
Recap：IP的作用、端口的作用、MAC地址的作用、交换机的作用、路由器的作用、域名的作用、DNS的作用、NAT的作用。</p>
<h2 id="gfw拦截的原理与绕过">GFW拦截的原理与绕过</h2>
<p>上面大概介绍了访问正常网站的通信流程，本节介绍被墙的网站如何实行拦截。</p>
<p><img src="/posts/cb82d49a.htm/Screenshot%202023-10-16%20202320.png" alt="Alt text"></p>
<p>在本地进行数据封装的流程与上面相同，在后续路由器端口的跳转中会经过GFW防火墙（长城防火墙）。防火墙会检查整个五层数据包。事实上在DNS解析过程中防火墙并不会在数据包跳转出去的过程做手脚，你的请求其实可以达到国外的服务器，并且国外的服务器会返回相应的目标IP地址。但在数据包返回的过程中也会经过GFW防火墙，防火墙在访问应用层的时候能够发现你实际上是对某个黑名单上的域名进行了DNS解析，于是它就会篡改数据中返回的目标IP地址，于是等到数据包再传回本地时里面的IP地址已经是不可用了。这个过程被称为DNS污染。<br>
那么是不是不发送DNS解析请求就不会被防火墙gank了呢？还记得上节提到本地在解析域名是会首先检查缓存，其次检查host文件有没有相应的映射关系，这就是我们可以做文章的地方。我们手动在host中添加正确映射关系就可以直接获得目标IP地址，这样就可以避免发送DNS解析请求而被墙。<br>
但是，因为我们在应用层使用HTTP协议，而HTTP协议基于传输层的TCP协议，这就意味着我们想要访问某个网站还需要与它建立链接，我们还是需要发送数据包与它进行通信。但是这个数据包在经过防火墙时就会出事了。因为防火墙可以检查四层数据包（TCP协议基于传输层），它可以清楚地知道你想要对某个IP地址进行链接，如果这个地址恰巧在防火墙的黑名单上，你的数据包就没了。它甚至可以伪装成你想要访问网站的服务器给你瞎回一个数据包，这样你的访问就又寄了。这个过程被称为TCP重置攻击。<br>
那么如果我们知道想要访问的服务器的另外一个不在黑名单的地址可不可以把数据包传出去呢（也就是使用HTTP或者socks5代理）？答案是可以的，防火墙在途中并不会检测到风险，因为目标IP地址和数据内容都不在黑名单上，这样我们就可以与正确的服务器建立连接。<br>
然而，建立连接后我们就需要想某个网站请求数据，在这个过程中又涉及到数据包的通信。如果请求数据中包含有黑名单上的内容，那么这个数据包就被干掉了。如此，虽然我们已经与正确的服务器建立了链接，我们依然不可以访问想要访问的网站。<br>
回顾上面被拦截的经历，归根结底是因为GFW防火墙可以窥探我们的请求数据，这样也就知道了我们的访问意图。VPN（Virtual Private Network，虚拟私人网络）可以为我们的数据进行加密。但是，一些传统的加密方法会有明显的特征，可以让防火墙知道你在进行VPN链接。虽然在这种情况下防火墙不会直接把你毙掉（因为一些公司合并也会用到VPN），但是他会把你的目标IP地址记录到监控名单中，如果在后续过程中发现了你长时间、大流量的链接，那么防火墙就会将你的连接阻断。<br>
所以，主角shadowsocks协议登场。这种协议即完成了加密，又不会有明显的特征。我们可以在shadowsocks的客户端中设置一个监听端口，从这个端口发出的数据都会被加密，然后打包传给我们的VPS（Virtual Private Server，虚拟专用服务器），这样在传输过程中IP地址和数据内容都不会被防火墙发现有问题。数据成功到达VPS后会进行解密，然后进行我们要进行的操作，之后将数据再加密打包返回，返回的过程中同样不会被防火墙发现IP地址和数据内容有问题。我们在本地进行解密后就可以得到想要的结果。<br>
但是，这个过程并不是天衣无缝的，GFW防火墙不只是被动探测，他也会主动向你的VPS发送数据进行检测，如果你使用的shadowsocks协议有漏洞，那么恭喜你，你又寄b了。<br>
Recap：DNS污染、SNI阻断、TCP重置、传统VPN的问题、shadowsocks</p>
<h2 id="创建vps与ss节点搭建">创建VPS与SS节点搭建</h2>
<p>自建节点的具体过程请自行上网查找，在这里我使用vultr购买了VPS，通过shadowsocks建立代理，之后使用了BBR和Kcptun进行加速。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Wrap-up post</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU DC：基于NVBoard实现键盘输入</title>
    <url>/posts/432132d9.html</url>
    <content><![CDATA[<h1 id="接入nvboard">接入NVBoard</h1>
<p>仿真第一步先为verilator接入NVBoard。NVBoard是一生一芯往届学生为学习数字电路实验开发的虚拟FPGA板。安装的具体步骤根据README里面的提示运行脚本文件并安装相关的依赖即可。</p>
<h1 id="键盘输入的具体实现">键盘输入的具体实现</h1>
<p>在键盘输入中除了基本的clk，resetn，ps2_clk，ps2_data和数码管输出之外，还定义了五个类型的变量。首先建立一个reg类型的十位buffer变量，作为接受ps2_data的地方，再定义一个reg类型的四位count变量，来为ps2_data的bit计数。reg类型的三位ps2_clk_sync是用作记录PS2时钟信号的历史信息并检测时钟的下降沿。cnt是用作记录按键被按下的次数的变量。除此之外还定义了34个状态，一个输入状态和一个输出状态，默认值都是S0。</p>
<p>在流程一开始先通过一个死循环，将ps2_clk时钟上的采样送到最低为并丢弃最高位，形成一个三位的时间队列。因为最新的采样放入的是最低位0位，所以计算ps2_clk_sync[2] &amp; ~ps2_clk_sync[1]。若为下降沿则sampling为1，上升沿为0。</p>
<p>接下来通过时序逻辑进行具体接受信号的处理。如果接收到的resetn为0，则将count置为零。如果sampling为真(也就是处于下降沿)，则判断count是否为10，如果是的话就进一步判断首位和末位是否为0和1，并进行奇偶校验(在数据的最后添加一个校验位，使得数据位和校验位中1的个数为奇数或偶数，如果接收方收到的数据位和校验位中1的个数不是奇偶性相同，就说明传输的数据出现了错误)。如果条件都满足就进行数码管的输出。对buffer的高四位和低四位分别用case语句进行判断。然后数码管输出对应的数字(注意这里数码管是低电平有效)。判断完buffer就对cnt进行判断，判断逻辑大致相同。输出玩数码管后将count置为零。如果count不是10就将ps2_data传到buffer对应的位数中，然后count加一。在case判断中除了输出数码管还要将cnt加一，以显示按键次数的增多。同时要将输出状态切到对应的状态，在代码最后将输出状态赋值给输入状态。</p>
<p>至此键盘输入功能全部实现。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归2：极大似然估计</title>
    <url>/posts/5afd1efa.html</url>
    <content><![CDATA[<h2 id="更复杂的模型">更复杂的模型</h2>
<p>上篇文章介绍了最基本的线性回归，文末的向量表示方法也允许我们进一步扩充模型的复杂度。<br>
我们现在可以使用四次方模型、八次方模型来提高复杂度。<br>
为了变得更加牛逼，我们还可以将原来公式：t = w0 + w1x + w2 * x^2 + … + wk * w^k<br>
中的x替换成函数，h(x)。<br>
函数的具体内容就可以发挥你的想象力了，指数、三角…<br>
如此原本矩阵<strong>X</strong>的内容就取决于函数h(x)了。</p>
<p>但正如上篇文章中所说，复杂性的增高并不意味着泛化能力一定提高，而我们应该怎么选取最合适的模型呢？</p>
<h2 id="测试">测试</h2>
<p>为了验证我们模型的性能，我们可以使用N - C个数据(N为数据总个数)去训练多个模型(也就是代入上篇文章中提到的计算<strong>w</strong>公式中)，对于剩余C个数据做出最好预测的模型就是质量最高的模型。我们将这N - C个数据称为训练集，C个数据称为测试集。<br>
计算测试损失同样可以使用之前的损失函数：</p>
<pre><code>Lv = 1/C Σ1-&gt;c (tc - **w**^T * xc)^2
</code></pre>
<p>通过这样的手段我们可以得知质量最好的模型实际上是最开始的线性模型(返璞归真了？)</p>
<p>但是我们应该怎么进行数据集和训练集的划分呢？</p>
<p>最通俗的手段就是基于合理性，拿上篇文章的奥林匹克运动会例子，使用最近几次奥运会的数据做测试集是最符合逻辑的。或者我们可以做多次测试，接下来要介绍的就是一种常见的检验手段——交叉验证(Cross-validation)。</p>
<h2 id="交叉验证与loocv">交叉验证与LOOCV</h2>
<p>在交叉验证中，我们将数据集平分成C份，拿出C-1份作为训练集，剩下的一份做测试集。<br>
再极端一点呢？<br>
我们假设数据集中一共有N份数据，令C = N，将数据集细细地划分成一对一对的数据，这样的验证方法称作LOOCV(leave-one-out cross-validation)。<br>
通过LOOCV我们可以得知质量最好的模型是三次模型，这与之前的检验结果可不一样。<br>
我们使用训练好得到的三次模型生成一些数据，再次进行验证，发现平均损失最小的还是三次模型！<br>
我们愉快的知道LOOCV的检验结果要更加可靠，但是其带来的计算开销也是十分明显的(不是谁都有耐心把肉细细地切成臊子)，当模型的次数达到一定程度时，我们还是要令C &lt; N的。</p>
<h2 id="概率的概率：密度公式">概率的概率：密度公式</h2>
<p>接下来，我们要将误差(或者说噪音)加入我们的模型当中，因为它们就在那里。但是误差看起来十分难用一个简单的函数进行描述，因为对于不同的数据误差都不同，并且误差可以是正或负，误差与不同数据之间貌似也没有联系。为了解决这些问题，我们可以将其作为一个随机变量(random variable)加入我们的模型当中。</p>
<p>接下来我们用硬币的例子来说明随机变量，我们假使硬币正面朝上的值为1，反面朝上的值为0，如此我们就可以用变量X来代表扔完硬币后的值。我们不知道X的具体值，但是我们知道它可能是哪些值并计算出相应的可能性。我们使用大写字母来代表随机值，用小写字母来代表可能值。</p>
<p>我们可以计算可能性，仍然使用硬币的例子：</p>
<pre><code>P(X = 1) = 0.5
P(X = 0) = 0.5
</code></pre>
<p>概率的值是受到限制的，其要在0和1之间，并且不同事件发生的概率(Discrete RVs)的和应是1。</p>
<p>但是我们不可能直接使用概率，因为我们无法直接计算它们。我们使用密度公式p(x)来取而代之。密度公式并不直接计算出概率。那骰子举个例子，我们假设这个骰子有六个面，分别标号123456，这就是p(x)中的x。骰子最后某一面朝上的概率是1/6，而是具体哪个序号的面朝上的概率就是用密度公式p(x)来表示。我们将上面提到的p(x)画在坐标系中，就可以得到一个函数，我们对于这段函数的某一段进行积分，就可以得到这个区间中某个序号朝上的概率之和。这个积分的值同样受到限制，p(x) &gt; 0，并且再正负无限之间积分的结果一定是1。</p>
<h2 id="联合概率和密度">联合概率和密度</h2>
<p>我们使用P(X = x, Y = y)来表示随机变量X是x的概率与随机变量Y是y的概率之和。对于两个连续的随机变量x0和x1来说，p(x0, x1)就是其联合密度。</p>
<h2 id="条件概率">条件概率</h2>
<p>独立与依赖的概念十分明晰，两个时间发生的概率只讲相互不影响就是独立事件，反之就存在依赖。对于相互依赖的事件，我们可以使用条件概率。即在给定另一个事件发生的条件下发生一个事件的概率。拿打球和下雨举例子，X代表我是否在打球，Y代表是否在下雨。我在下雨的条件下打球可以表示为以下公式：</p>
<pre><code>P(X = 1|Y = 1)
P(X = x, Y = y) = P(X = x|Y = y)P(Y = y)
</code></pre>
<h2 id="具体的密度公式">具体的密度公式</h2>
<p>于是乎我们就可以得到我们现在的模型了：<br>
tn = <strong>w</strong>^T * <strong>x</strong> + 误差<br>
接下来我们就可以为p(x)选取具体的函数了，在这里我们选择正态分布(Gaussian Distribution)。</p>
<pre><code>p(x|µ, σ^2) = 1/σ√2π exp &#123; −1/2σ^2 (x − µ)^2 &#125;
</code></pre>
<p>(很丑，建议自己上网找一下标准公式)<br>
我们在这里有两个参数，平均µ和变化率σ^2。<br>
平均控制钟峰的中心位置，变化率控制钟的宽度。</p>
<p>接下来我们就可以用这个函数来生成数据了。<br>
我们暂时选取µ=0，σ^2=0.05。(将µ=0是因为为正的误差并不一定比为负的误差多，反之亦然)</p>
<h2 id="可能性-likelihood">可能性(Likelihood)</h2>
<p>通过模型所预测出的数据是真实的数据的可能性(Likelihood)，也就是我们评判密度函数好坏的方法。我们让tn作为一个定值，通过调整<strong>w</strong>和σ^2来最大化可能性，就像之前最小化平方损失一样。但是通过可能性判断模型的优劣实际上要比平方损失更加科学，因为其将误差也计算在了模型内，而平方损失直接忽视了误差。</p>
<h2 id="可能性最优化-likelihood-optimisation">可能性最优化(Likelihood optimisation)</h2>
<p>模型最好的情况就是很好地拟合了数据并且训练数据为真的可能性很高。<br>
上面提到我们可以通过密度函数来计算在某一条件下tn数据为真的可能性。我们同样可以像联合概率一样将可能性联合起来：</p>
<pre><code>p(t1, ... , tn|w, σ^2, x1, ... , xn) = product of p(tn|w, xn, σ^2)
</code></pre>
<p>我们可以直接将可能性累乘因为tn数据之间是相互独立的。<br>
如此可能性的最优化就可以简化为通过调整w和σ^2最大化乘积。<br>
在这里我们可以为乘积套上自然对数来减少计算复杂度，因为log的值随着自变量的增加而增加，减少而减少。<br>
现在我们可以得到：</p>
<pre><code>logL = log (product of p(tn|w, xn, σ^2)) = -Nlog(σ√2π) - 1/σ^2 Σ1-&gt;N (tn - w^T * xn)^2
</code></pre>
<p>现在公式就变得熟悉了，后半部分实际上就是平方损失。<br>
于是我们现在只需要对两个参数分别进行偏微分就可以得到最优的可能性。<br>
但是我们还可以让事情变得更简单，通过对于多元高斯函数的学习，我们可以得出以下的式子：</p>
<pre><code>logL = log (product of p(tn|w, xn, σ^2)) = logN(Xw, σ^2*I) = log p(t|w, X, σ^2)
</code></pre>
<p>对w进行偏微分之后，我们就可以得到当可能性最优时参数w的值：</p>
<pre><code>w = (X^T * X)^-1 * X^T * t
</code></pre>
<p>让人震惊的是，这个参数与之前的式子没有任何区别。<br>
我们再对σ^2进行偏微分：</p>
<pre><code>σ^2 = 1/N (t - Xw)^T * (t - Xw)
</code></pre>
<p>实际上与平均平方损失是相同的。</p>
<h2 id="期望-expectations">期望(Expectations)</h2>
<p>期望可以对我们参数的不确定性进行量化。我们在密度函数上随机选取S个值，求和并取平均值，这就是期望。一般的我们将其写为：</p>
<pre><code>Ep(x) &#123;f(x)&#125; = ∫f(x)p(x)dx
</code></pre>
<p>由此我们可以得到：</p>
<pre><code>Variance: σ^2 = Ep(x)&#123;(x-μ)^2&#125; = Ep(x)&#123;x^2&#125; - (Ep(x)&#123;x&#125;)^2
Mean: μ = Ep(x)&#123;x&#125;
Covariance: cov&#123;x&#125; = Ep(x)&#123;(x-μ)(x-μ)^T&#125; = Ep(x)&#123;xx^T&#125; - Ep(x)&#123;x&#125;Ep(x)&#123;x^T&#125;

For Uni-variate:
    p(x|μ, σ^2) = N(μ, σ^2)
    Mean: Ep(x)&#123;x&#125; = μ
    Variance: Ep(x)&#123;(x-μ)^2&#125; =  σ^2

For Multi-variate:
    p(x|μ, σ^2) = N(μ, Σ)
    Mean: Ep(x)&#123;x&#125; = μ
    Variance: Ep(x)&#123;(x-μ)(x-μ)^T&#125; = Σ
    
Parameter estimates:
    w = (X^T * X)^-1 * X^T * T
    σ^2 = 1/N * (t-Xw)^T * (t-Xw)
</code></pre>
<p>我们的密度模型现在变成了这样：</p>
<pre><code>p(t|X, w, σ^2) = N(Xw, σ^2I)
</code></pre>
<p>现在我们可以利用期望对参数w进行验证，最后发现是其本身，这证明其是真的，在模型正确的前提下。<br>
误差(Error) = 偏差(Bias) + 方差(Variance)<br>
偏差反应的是模型在样本上的输出与真实值之间的误差，方差反映的是模型每一次输出结果与模型输出期望之间的误差。<br>
上面期望的验证证明w是没有偏差的，w就是真实的值。<br>
那么cov{w}告诉了我们什么呢？<br>
是参数在哪个范围内进行调整不会影响输出的准确度。</p>
<pre><code>cov&#123;w&#125; = σ^2 * (X^T * X)^-1
</code></pre>
<p>再对σ^2进行期望检验，得出的值是 σ^2(1-D/N)<br>
一般的，D &lt; N，这也就导致σ^2的值是有偏差的，并且其值会变得越来越低。</p>
<p>写到这里先不写了，主要介绍了最小化平方损失和最大化可能性的方法。机器学习与数学的勾连实在太深了，如果要把剩下的东西讲完要求远远高于我现在的数学能力，以后数学变好了再来写完吧…<br>
源码地址：<a href="http://csml-cam.github.io/resources">csml-cam.github.io/resources</a></p>
]]></content>
      <categories>
        <category>Machine Learning/Statistics</category>
      </categories>
      <tags>
        <tag>Wrap-up post</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归1：最小二乘法</title>
    <url>/posts/c7765b88.html</url>
    <content><![CDATA[<p>本篇文章做一个简单的机器学习引入，并且介绍机器学习中最简单的方法——线性回归。</p>
<h2 id="什么是机器学习">什么是机器学习?</h2>
<p>机器学习从数据开始：</p>
<ul>
<li>数据可以是对于人的观察(偏好、健康…)</li>
<li>数据也可以是对于世界的观察(图像、声音…)</li>
</ul>
<p>通过机器学习，我们可以找到相似的对象、为对象做预测、从对象身上总结知识、为对象分组…</p>
<h2 id="算法-算法">算法！算法！</h2>
<p>机器学习可以被认为是一个拥有不断增长的数据集的算法。<br>
但是算法很难被应用到实际，并且在应用过程中可能会进行调整，所以理解他们是必要的。</p>
<p>AI -&gt; Neural Networks -&gt; Modelling biological neurons &amp; Predicting stuff from data</p>
<p>机器学习的实例可以是谷歌、微软或亚马逊等商业公司的推荐机制…<br>
也可以是通过学习人类基因片段来诊断病症…<br>
可以是信息检索：新闻检索、语言模型预测、图像和视频检索…<br>
或者是人机交互：语音识别、姿势识别…<br>
可以与生物信息相关：预测生物与基因反应、预测基因和蛋白质网络结构、通过序列预测蛋白质功能…</p>
<h2 id="监督学习-supervised-learning">监督学习(Supervised Learning)</h2>
<p>机器学习分为三大板块：监督学习、无监督学习和强化学习，本文暂时只讨论前两种。</p>
<p>监督学习，顾名思义，即是基于已经标识好的数据集进行训练(训练过程像是做一本有答案的练习册)。</p>
<h3 id="回归-regression">回归(Regression)</h3>
<p>回归是监督学习的一种，即从数据集中总结出一种连续的函数。<br>
例子：预测股票价格(参数可以是时间或者跟利息相关的其他变量)。</p>
<h3 id="分类-classification">分类(Classification)</h3>
<p>学习一种可以将不同对象区分开的规则。<br>
例子：疾病诊断，垃圾邮件检测。</p>
<h2 id="无监督学习-unsupervised-learning">无监督学习(Unsupervised Learning)</h2>
<p>继续上面练习册的例子，无监督学习即是做一本没有答案的练习册，自己总结规律。</p>
<h3 id="聚类-clustering">聚类(Clustering)</h3>
<p>为相似的对象划分组别。<br>
例子：具有相同偏好的人，具有相似功能的基因。</p>
<h3 id="投影-projection">投影(Projection)</h3>
<p>减少参数数量。<br>
例子：将复杂的数据可视化。</p>
<p>当然上述算法的介绍是十分泛泛的，以后应该会补全的…吧？ —2023.08.14</p>
<h2 id="回归的伊始：线性回归">回归的伊始：线性回归</h2>
<p>我们使用1896-2000年间奥林匹克运动会一百米赛的金牌数据进行训练，随后对2004、2008、2012以及2016年的金牌时间进行预测。(具体数据可以到www.statisca.com进行查找)</p>
<p>为了使用线性回归做的一些假设(错误的)：</p>
<ul>
<li>奥林匹克举办年份与获奖时间之间存在关系。(实则不然，年份只是训练方法、医疗条件等等进步的一个外显)</li>
<li>关系是线性的。(实则不然，获奖时间明显是波动下降)</li>
<li>会一直保持线性关系。(那将来的某一天获奖时间会变成负的喽？)</li>
</ul>
<p>综上，线性回归作为新手入门手段，仍然存在许多局限性，在此先忽略这些错误。</p>
<p>属性(Attributes)和目标(Targets)：<br>
属性是影响预测结果的因变量，在这里即是年份。目标是要进行预测的对象，在这里即是获奖时间。</p>
<p>数学意义上，我们可以用变量x和变量t来表示这两个参数。<br>
如此我们便得到了预测模型，t = f(x)。<br>
我们有若干个带答案数据集(attribute-response pairs)。<br>
将上面的模型展开，我们可以得到t = f(x) = w0 + w1*x<br>
w0和w1是线性模型的两个参数。<br>
如此我们便得到了数据和要进行调整的参数。</p>
<p>那么我们如何评判模型的优劣呢？下面介绍一种简单的损失函数，平方损失。</p>
<p>Lossn = (tn - f(xn; w0; w1))^2</p>
<p>平均损失即是：</p>
<p>Lossn = 1/N Σ1-&gt;n (tn - f(xn; w0; w1))^2</p>
<p>Lower is better.</p>
<p>因此我们要对上述损失函数进行求导，如此便可以找到损失最小的参数。<br>
问题来了，当参数多于两个时该怎么导损失函数呢？偏微分。<br>
中间冗长的(或许也不，只是这里不好写公式)推算先略去不表，我们最终得出了当损失最小时参数w1和参数w0的公式：</p>
<p>w1 = (xt_bar - x_bar<em>t_bar)/(x_square_bar - x_bar</em>x_bar)<br>
w0 = t_bar - w1*x_bar</p>
<p>如此我们便得到了质量最高的线性回归模型。<br>
以下为c++的代码实现(太简单了所以没放github)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    float w1, w0, x_bar, t_bar, xt_bar, x_square_bar, pre_2004, pre_2008, pre_2012, pre_2016;</span><br><span class="line">    </span><br><span class="line">    t_bar = (131 + 121.2 + 116 + 112.8 + 111.9 + 113.4 + 112.4 + 111.8 </span><br><span class="line">    + 109.8 + 112.9 + 109.2 + 109.2 + 107.7 + 106.3 + 105.1 + 104.3 </span><br><span class="line">    + 105.86 + 103.5 + 105.4 + 103 + 103.55 + 103.66 + 102.58 + 105.08)/24;</span><br><span class="line"></span><br><span class="line">    x_bar = (1896 + 1900 + 1904 + 1908 + 1912 + 1920 + 1924 </span><br><span class="line">    + 1928 + 1932 + 1936 + 1948 + 1952 + 1956 + 1960 + 1964 + 1968</span><br><span class="line">    + 1972 + 1976 + 1980 + 1984 + 1988 + 1992 + 1996 + 2000)/24;</span><br><span class="line">    </span><br><span class="line">    xt_bar = (131*1896 + 121.2*1900 + 116*1904 + 112.8*1908 + 111.9*1912 </span><br><span class="line">    + 113.4*1920 + 112.4*1924 + 111.8*1928 + 109.8*1932 + 112.9*1936 + 109.2*1948</span><br><span class="line">    + 109.2*1952 + 107.7*1956 + 106.3*1960 + 105.1*1964 + 104.3*1968 + 105.86*1972</span><br><span class="line">    + 103.5*1976 + 105.4*1980 + 103*1984 + 103.55*1988 + 103.66*1992 + 102.58*1996</span><br><span class="line">    + 105.08*2000)/24;</span><br><span class="line">    </span><br><span class="line">    x_square_bar = (1896*1896 + 1900*1900 + 1904*1904 + 1908*1908 + 1912*1912 + 1920*1920 + 1924*1924 </span><br><span class="line">    + 1928*1928 + 1932*1932 + 1936*1936 + 1948*1948 + 1952*1952 + 1956*1956 + 1960*1960 + 1964*1964 + 1968*1968</span><br><span class="line">    + 1972*1972 + 1976*1976 + 1980*1980 + 1984*1984 + 1988*1988 + 1992*1992 + 1996*1996 + 2000*2000)/24;</span><br><span class="line">    </span><br><span class="line">    w1 = (xt_bar-x_bar*t_bar)/(x_square_bar-x_bar*x_bar);</span><br><span class="line">    w0 = t_bar - w1*x_bar;</span><br><span class="line"></span><br><span class="line">    pre_2004 = w0 + w1*2004;</span><br><span class="line">    pre_2008 = w0 + w1*2008;</span><br><span class="line">    pre_2012 = w0 + w1*2012;</span><br><span class="line">    pre_2016 = w0 + w1*2016;</span><br><span class="line"></span><br><span class="line">    printf(&quot;x_bar = %.2f\n&quot;, x_bar);</span><br><span class="line">    printf(&quot;t_bar = %.2f\n&quot;, t_bar);</span><br><span class="line">    printf(&quot;xt_bar = %.2f\n&quot;, xt_bar);</span><br><span class="line">    printf(&quot;x_square_bar = %.2f\n&quot;, x_square_bar);</span><br><span class="line">    printf(&quot;The two parameters are: w0 = %.2f, w1 = %.2f\n&quot;, w0, w1);</span><br><span class="line">    printf(&quot;The equation is t = f(x) = %.2f + %.2fx\n&quot;, w0, w1);</span><br><span class="line">    printf(&quot;The predicted time of gold medal in 800m race in 2004 is %.2f seconds\n&quot;, pre_2004);</span><br><span class="line">    printf(&quot;The real time of gold medal in 800m race in 2004 is 104.45 seconds. \n&quot;);</span><br><span class="line">    printf(&quot;The predicted time of gold medal in 800m race in 2008 is %.2f seconds\n&quot;, pre_2008);</span><br><span class="line">    printf(&quot;The real time of gold medal in 800m race in 2008 is 104.65 seconds. \n&quot;);</span><br><span class="line">    printf(&quot;The predicted time of gold medal in 800m race in 2012 is %.2f seconds\n&quot;, pre_2012);</span><br><span class="line">    printf(&quot;The real time of gold medal in 800m race in 2012 is 100.91 seconds. \n&quot;);</span><br><span class="line">    printf(&quot;The predicted time of gold medal in 800m race in 2016 is %.2f seconds\n&quot;, pre_2016);</span><br><span class="line">    printf(&quot;The real time of gold medal in 800m race in 2016 is 102.15 seconds. \n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向量表示方法">向量表示方法</h2>
<p>到这里一个简单的线性回归程序已经编写好了，但是我们还需要进一步的完善。<br>
我们可以发现在上面定义的模型实际上只是一条直线，为了提高模型能力，我们可以增加参数的次数。<br>
增加函数的次数可以让函数的拟合能力变强，因为整个函数会变得十分灵活，模型越复杂(次数越高)则模型的Loss越低。但是这里要注意一点，损失的减少并不意味着模型泛化(generalization, predictive ability)能力一定提高，要找到合适的模型复杂度，一味提高次数会导致过拟合(over-fitting, decreasing the loss)。</p>
<p>因为参数增加了，在使用上面最高二次的表示方法未免会显得很蠢，所以我们在这里引用向量表示方法。<br>
我们令<strong>w</strong>表示一个2 * 1的向量，包含w0和w1，令<strong>x</strong>同样表示为一个2 * 1的向量，包括x0和x1。如此我们便可以将上面的模型：<br>
t = w0 + w1*x = Σ0-&gt;k wk * xk<br>
简化为：<br>
t = <strong>w</strong> ^ T * <strong>x</strong><br>
损失为：<br>
Ln = (tn - <strong>w</strong> ^ T * <strong>x</strong>n)^2<br>
平均损失为：<br>
L = 1/N Σ1-&gt;N (tn - <strong>w</strong> ^ T * <strong>x</strong>n)^2</p>
<p>优雅的表示方法！<br>
但这样就足够了吗？</p>
<p>我们令qn = (tn - <strong>w</strong> ^ T * <strong>x</strong>n)，也就是一个N * 1的向量<br>
如此我们又可以对损失公式进行简化：<br>
L = 1/N <strong>q</strong> ^ T * <strong>q</strong></p>
<p>我们接着设<strong>X</strong>为N * 1的矩阵，包括x1到xn。(矩阵是粗体大写字母，向量是粗体小写字母)<br>
于是我们可以得到<strong>q</strong> = <strong>t</strong> - <strong>X</strong> * <strong>w</strong><br>
而平均损失函数也可以更新为：<br>
L = 1/N (<strong>t</strong> - <strong>X</strong> * <strong>w</strong>) ^ T * (<strong>t</strong> - <strong>X</strong> * <strong>w</strong>)</p>
<p>对于损失函数的偏微分计算同样略去不表，这里给出最后参数的公式：<br>
<strong>w</strong> = (<strong>X</strong> ^ T * <strong>X</strong>)^-1 * <strong>X</strong> ^ T * <strong>t</strong></p>
<p>本篇文章到此结束。</p>
]]></content>
      <categories>
        <category>Machine Learning/Statistics</category>
      </categories>
      <tags>
        <tag>Wrap-up post</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式速览</title>
    <url>/posts/6dc30208.html</url>
    <content><![CDATA[<h1 id="限定符">限定符</h1>
<pre><code>?: 表示某一个词元可以出现零次或一次，例：used?可以匹配use和used。
*：表示某一个词元可以出现零次或多次，例：ab*c可以匹配ac, abc, abbc...
**注：词元在这里是我生造的词汇，表示某一个具体的字母，符号或数字。**
+：表示某一个词元必须出现一次以上。
&#123;...&#125;(数字)：括号内的数字表示某一个词元必须出现的特定次数。&#123;2&#125;，为出现两次，&#123;2,6&#125;，为出现2到6次，&#123;2，&#125;为出现2次以上。
&#123;...&#125;(字母)：如果想对多个词元进行限定符操作，则用括号将其括起来。如&#123;ab&#125;。
^：匹配除了后续括号内以外的字符。
</code></pre>
<h1 id="或运算符">或运算符</h1>
<pre><code>例子：a (cat|dog)
匹配结果：a cat, a dog
</code></pre>
<h1 id="字符类运算符">字符类运算符</h1>
<pre><code>[...]：指定了能匹配的字符范围，如[abc]+表示所有abc，[a-zA-z]+代表所有的英文字符，[0-9]+代表所有的数字。
</code></pre>
<h1 id="元字符">元字符</h1>
<pre><code>元字符是预先定义好的匹配规则。
\d+：代表所有数字内容。
\w+：代表所有英文字符内容。
\s+：代表空白字符，包括tab和换行符。
\D+：非数字内容。
\W+：非英文字符内容。
\S+：非空白内容。
.+：代表任意字符。
^x：只会匹配行首的字符。
$x：只会匹配行尾的字符。
</code></pre>
<p>PA1阶段并不需要对正则表达式多么高深的理解，所以本篇文章到此暂时结束。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Wrap-up post</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU 15122：Transitioning to C</title>
    <url>/posts/cmu15122note4.html</url>
    <content><![CDATA[<h1 id="graph-representation">Graph Representation</h1>
<h2 id="graph-interface">Graph Interface</h2>
<p>Graph是Undirected的（15122定义），也就是说对于vertex A和B，BA和AB是一条edge。我们将graph表示成一个data structure，其中vertex定义为无符号整数。那么一个基本的graph interface可以如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef unsigned int vertex;</span><br><span class="line">typedef struct graph_header *graph_t;</span><br><span class="line"></span><br><span class="line">graph_t graph_new(unsigned int numvert);</span><br><span class="line">//@ensures \result != NULL;</span><br><span class="line"></span><br><span class="line">void graph_free(graph_t G);</span><br><span class="line">//@requires G != NULL;</span><br><span class="line"></span><br><span class="line">unsigned int graph_size(graph_t G);</span><br><span class="line">//@requires G != NULL;</span><br><span class="line"></span><br><span class="line">bool graph_hasedge(graph_t G, vertex v, vertex w);</span><br><span class="line">//@requires G != NULL;</span><br><span class="line">//@requires v &lt; graph_size(G) &amp;&amp; w &lt; graph_size(G);</span><br><span class="line"></span><br><span class="line">void graph_addedge(graph_t G, vertex v, vertex w);</span><br><span class="line">//@requires G != NULL;</span><br><span class="line">//@requires v &lt; graph_size(G) &amp;&amp; w &lt; graph_size(G);</span><br><span class="line">//@requires v != w &amp;&amp; !graph_hasedge(G, v, w);</span><br><span class="line"></span><br><span class="line">typedef struct neighbor_header *neighbors_t;</span><br><span class="line"></span><br><span class="line">neightbors_t graph_get_neighbors(graph_t G, vertex v);</span><br><span class="line">//@requires G != NULL &amp;&amp; v &lt; graph_size(G);</span><br><span class="line">//@ensures \result != NULL;</span><br><span class="line"></span><br><span class="line">bool graph_hasmore_neighbors(neighbors_t nbors);</span><br><span class="line">//@requires nbors != NULL;</span><br><span class="line"></span><br><span class="line">vertex graph_next_neighbor(neighbors_t nbors);</span><br><span class="line">//@requires nbors != NULL;</span><br><span class="line">//@requires graph_hasmore_neighbors(nbors);</span><br><span class="line"></span><br><span class="line">void graph_free_neighbors(neighbors_t nbors);</span><br><span class="line">//@requires nbors != NULL;</span><br></pre></td></tr></table></figure>
<p>我们通过graph_hasmore_neighbors和graph_next_neighbors来检查或者获取某个vertex的相邻vertex。我们可以通过多种数据结构实现上面的interface，一个有e条边的graph可以被链表或者edge的数组来表示。在链表实现中，添加一个edge的时间复杂度是O(1)，因为可以直接在链表前面接上。但是检查某一个edge是否存在需要O(e)的复杂度因为要遍历整个graph。获取某个节点的相邻节点同样需要O(e)的复杂度(Worst case)。使用哈希表和自平衡二分树也可以实现graph，但是这里只涉及到使用adjacency matrices和adjacency lists的graph实现。</p>
<h2 id="adjacency-matrices">Adjacency Matrices</h2>
<p>我们可以使用一个二维数组储存两个节点之间是否存在edge，这样的表示方法在这里被称为Adjacency Matrices。假设我们有节点B(=1)和节点D(=3)，我们检查两个节点之间是否存在edge的方法就是看二维数组的row 1，column 3。在一个不区分方向的图中，数组的右上半边是左下的镜像。因为edge的关系是对称的。因为我们不允许一个node使用edge链接自己，所以这个matrix的对角线是空的。</p>
<p>Adjacency Matrices的实现需要很多空间。对于一个有v个节点的graph我们需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(v^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的复杂度来分配内存。但是，使用改方法的好处是添加edge和检查edge的操作都是O(1)复杂度。</p>
<p>假如一个graph有0到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>v</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{v(v-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个节点数v，并且多数edge存在，那么总edge数和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">v^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>成比例关系，我们说这样的graph是dense的。对于dense graph，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(e) = O(v^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因此adjacency matrices是表示其的较好办法。因为存储其的空间并不比linked list多，但是操作更快。</p>
<h2 id="adjacency-lists">Adjacency Lists</h2>
<p>我们将dense graph的对立称作sparse graph。Adjacency lists适合作为sparse graph的实现。在这个实现当中，我们有一个类似于哈希表的一维数组，每一个vertex都在数组中有一个位置，并且数组中的每一个元素包含所有其他和该vertex相连的链表。</p>
<p>这个实现需要O(v + e)的空间来存储有v个vertex和e个edge的graph。也可以被写作O(max(v, e))。添加一个edge需要的时间是constant，但是lookup某一个edge需要的时间是O(min(v, e))，因为min(v-1, e)是每一个adjacency list的最大长度。在adjacency list实现里面寻找一个neighbor的时间是O(1)。</p>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct adjlist_node adjlist</span><br><span class="line">struct adjlist_node&#123;</span><br><span class="line">  vertex vert;</span><br><span class="line">  adjlist *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct graph_header graph;</span><br><span class="line">struct graph_header&#123;</span><br><span class="line">  unsigned int size;</span><br><span class="line">  adjlist **adj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_vertex(graph *G, vertex v)&#123;</span><br><span class="line">  REQUIRES(G != NULL);</span><br><span class="line">  return v &lt; G-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_in(adjlist *p, vertex v)&#123;</span><br><span class="line">  while(p != NULL)&#123;</span><br><span class="line">    if(p-&gt;vert == v) return true;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_graph(graph *G)&#123;</span><br><span class="line">  if(G == NULL) return false;</span><br><span class="line">  if(G-&gt;adj == NULL) return false;</span><br><span class="line">  for(unsigned int i = 0; i &lt; G-&gt;size; i++)&#123;</span><br><span class="line">    if(!is_acyclic(G-&gt;adj[i])) return false;</span><br><span class="line">    for(adjlist *p = G-&gt;adj[i]; p != NULL; p = p-&gt;next)&#123;</span><br><span class="line">      if(p-&gt;vert == i || !(is_vertex(G, p-&gt;vert))) return false;</span><br><span class="line">      if(!is_in(G-&gt;adj[p-&gt;vert], i)) return false;</span><br><span class="line">      if(is_in(p-&gt;next, p-&gt;vert)) return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph *graph_new(unsigned int size)&#123;  </span><br><span class="line">  graph *G = xmalloc(sizeof(graph));</span><br><span class="line">  G-&gt;size = size;</span><br><span class="line">  G-&gt;adj = xcalloc(size, sizeof(adjlist*));</span><br><span class="line">  ENSURES(is_graph(G));</span><br><span class="line">  return G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool graph_hasedge(graph *G, vertex v, vertex w)&#123;</span><br><span class="line">  REQUIRES(is_graph(G) &amp;&amp; is_vertex(G, v) &amp;&amp; is_vertex(G, w));</span><br><span class="line">  for(adjlist *L = G-&gt;adj[v]; L != NULL; L = L-&gt;next)&#123;</span><br><span class="line">    if(L-&gt;vert = w) return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void graph_addedge(graph *G, vertex v, vertex w)&#123;</span><br><span class="line">  REQUIRES(is_graph(G) &amp;&amp; is_vertex(G, v) &amp;&amp; is_vertex(G, w));</span><br><span class="line">  REQUIRES(v != w &amp;&amp; !graph_hasedge(G, v, w));</span><br><span class="line"></span><br><span class="line">  adjlist *L;</span><br><span class="line">  L = xmalloc(sizeof(adjlist));</span><br><span class="line">  L-&gt;vert = w;</span><br><span class="line">  L-&gt;next = G-&gt;adj[v];</span><br><span class="line">  G-&gt;adj[v] = L;</span><br><span class="line"></span><br><span class="line">  L = xmalloc(sizeof(adjlist));</span><br><span class="line">  L-&gt;vert = v;</span><br><span class="line">  L-&gt;next = G-&gt;adj[w];</span><br><span class="line">  G-&gt;adj[w] = L;</span><br><span class="line"></span><br><span class="line">  ENSURES(is_graph(G));</span><br><span class="line">  ENSURES(graph_hasedge(G, v, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct neighbor_header&#123;</span><br><span class="line">  adjlist *next_neighbor;</span><br><span class="line">&#125;</span><br><span class="line">typedef struct neighbor_header neighbors;</span><br><span class="line"></span><br><span class="line">neighbors *graph_get_neighbors(graph *G, vertex v)&#123;</span><br><span class="line">  REQUIRES(is_graph(G) &amp;&amp; is_vertex(G, v));</span><br><span class="line">  neighbors *nbors = xmalloc(sizeof(neighbors));</span><br><span class="line">  nbors-&gt;next_neighbor = G-&gt;adj[v];</span><br><span class="line">  ENSURES(is_neighbors(nbors));</span><br><span class="line">  return nbors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool graph_hasmore_neighbors(neighbors *nbors)&#123;</span><br><span class="line">  REQUIRES(is_neighbors(nbors));</span><br><span class="line">  return nbors-&gt;next_neighbor != NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vertex graph_next_neighbor(neighbors *nbors)&#123;</span><br><span class="line">  REQUIRES(is_neighbors(nbors));</span><br><span class="line">  REQUIRES(graph_hasmore_neighbors(nbors));</span><br><span class="line"></span><br><span class="line">  vertex v = nbors-&gt;next_neighbor-&gt;vert;</span><br><span class="line">  nbors-&gt;next_neighbor = nbors-&gt;next_neighbor-&gt;next;</span><br><span class="line">  return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void graph_free_neighbors(neighbors *nbors)&#123;</span><br><span class="line">    free(nbors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Course Notes</tag>
      </tags>
  </entry>
</search>
