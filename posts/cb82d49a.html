<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>节点搭建指南 | Shoufeng's Blog</title><link rel="stylesheet" href="/css/minimalfolio.css"><meta name="generator" content="Hexo 7.0.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><header class="site-header"><div class="container"><a class="logo" href="/">Shoufeng's Blog</a><nav class="main-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/categories/">Categories</a></li></ul></nav></div></header><main class="container post"><article><h1 class="post-title">节点搭建指南</h1><p class="post-meta">2023-10-16</p><div class="post-content"><h2 id="网络通信的基本过程">网络通信的基本过程</h2>
<p>五层基本模型：应用层、传输层、网络层、数据链路层、物理层。<br>
数据包格式：| 源MAC | 目标MAC | 源IP | 目标IP | 源端口 | 目标端口 | 数据 |<br>
访问网址时首先在本地缓存检查是否存有域名绑定的IP地址，没有的话继续检查本地host文件，然后访问电脑中配置的DNS服务器（应用层协议，发送请求）。<br>
请求传到传输层，将应用层的数据封装，源端口为404，DNS默认目标端口是53（封装端口）。继续将封装好的数据包向下传，在网络层在数据包中添加源IP和目标IP（目标IP是DNS服务器的IP）。<br>
如果电脑发现目标IP不在网段范围内，则请求网关（家庭中通常是路由器），传到数据链路层。在数据链路层继续将本机MAC地址和网关MAC地址封装到数据包中（同一局域网内的通信用MAC地址），同时在数据包后面插入一些数据做校验。<br>
这样数据包就能顺着物理层来到网卡接口，通过网线发到交换器。交换器只能解析两层的数据，通过解析数据链路层封装的MAC地址，交换器可以将数据包发送给路由器，而路由器可以解析三层数据，然后将MAC的数据头删掉。<br>
路由器之后会将数据包转发给公网上的其他路由器（因为路由器没有跟DNS服务器直接连接）。因为数据包中记录的IP地址是内网通信的，所以路由器要将内网IP和源端口放到NAT映射表中，然后将映射成公网IP和端口。更改后再传回数据链路层，再将MAC地址添加到数据包中，最后放到物理层中传给其他路由器。<br>
经过一系列传递后找到DNS服务器，源MAC地址和目标MAC地址在传递过程中会发生改变。因为DNS是应用层协议，可以解析到应用层。最后经过DNS服务器的自下而上层层解析得到希望的IP地址。之后DNS服务器会仿照上面的传输方式重新将目标IP地址重新封装成数据包，再通过物理网口传回原来的路由器。路由器再自下而上解析，自上而下封装传给交换机。交换器直接传给本地，本地再自下而上层层解析，这样电脑就可以得到目标IP地址。<br>
电脑得到目标网站的IP地址之后就可以将实际的请求重新进行打包发给目标服务器。数据封装、传输、解析、返回的流程和上面请求DNS服务器一样。值得注意的是这里的目标IP地址就变成了网站域名绑定的IP地址。<br>
Recap：IP的作用、端口的作用、MAC地址的作用、交换机的作用、路由器的作用、域名的作用、DNS的作用、NAT的作用。</p>
<h2 id="gfw拦截的原理与绕过">GFW拦截的原理与绕过</h2>
<p>上面大概介绍了访问正常网站的通信流程，本节介绍被墙的网站如何实行拦截。</p>
<p><img src="/posts/cb82d49a.htm/Screenshot%202023-10-16%20202320.png" alt="Alt text"></p>
<p>在本地进行数据封装的流程与上面相同，在后续路由器端口的跳转中会经过GFW防火墙（长城防火墙）。防火墙会检查整个五层数据包。事实上在DNS解析过程中防火墙并不会在数据包跳转出去的过程做手脚，你的请求其实可以达到国外的服务器，并且国外的服务器会返回相应的目标IP地址。但在数据包返回的过程中也会经过GFW防火墙，防火墙在访问应用层的时候能够发现你实际上是对某个黑名单上的域名进行了DNS解析，于是它就会篡改数据中返回的目标IP地址，于是等到数据包再传回本地时里面的IP地址已经是不可用了。这个过程被称为DNS污染。<br>
那么是不是不发送DNS解析请求就不会被防火墙gank了呢？还记得上节提到本地在解析域名是会首先检查缓存，其次检查host文件有没有相应的映射关系，这就是我们可以做文章的地方。我们手动在host中添加正确映射关系就可以直接获得目标IP地址，这样就可以避免发送DNS解析请求而被墙。<br>
但是，因为我们在应用层使用HTTP协议，而HTTP协议基于传输层的TCP协议，这就意味着我们想要访问某个网站还需要与它建立链接，我们还是需要发送数据包与它进行通信。但是这个数据包在经过防火墙时就会出事了。因为防火墙可以检查四层数据包（TCP协议基于传输层），它可以清楚地知道你想要对某个IP地址进行链接，如果这个地址恰巧在防火墙的黑名单上，你的数据包就没了。它甚至可以伪装成你想要访问网站的服务器给你瞎回一个数据包，这样你的访问就又寄了。这个过程被称为TCP重置攻击。<br>
那么如果我们知道想要访问的服务器的另外一个不在黑名单的地址可不可以把数据包传出去呢（也就是使用HTTP或者socks5代理）？答案是可以的，防火墙在途中并不会检测到风险，因为目标IP地址和数据内容都不在黑名单上，这样我们就可以与正确的服务器建立连接。<br>
然而，建立连接后我们就需要想某个网站请求数据，在这个过程中又涉及到数据包的通信。如果请求数据中包含有黑名单上的内容，那么这个数据包就被干掉了。如此，虽然我们已经与正确的服务器建立了链接，我们依然不可以访问想要访问的网站。<br>
回顾上面被拦截的经历，归根结底是因为GFW防火墙可以窥探我们的请求数据，这样也就知道了我们的访问意图。VPN（Virtual Private Network，虚拟私人网络）可以为我们的数据进行加密。但是，一些传统的加密方法会有明显的特征，可以让防火墙知道你在进行VPN链接。虽然在这种情况下防火墙不会直接把你毙掉（因为一些公司合并也会用到VPN），但是他会把你的目标IP地址记录到监控名单中，如果在后续过程中发现了你长时间、大流量的链接，那么防火墙就会将你的连接阻断。<br>
所以，主角shadowsocks协议登场。这种协议即完成了加密，又不会有明显的特征。我们可以在shadowsocks的客户端中设置一个监听端口，从这个端口发出的数据都会被加密，然后打包传给我们的VPS（Virtual Private Server，虚拟专用服务器），这样在传输过程中IP地址和数据内容都不会被防火墙发现有问题。数据成功到达VPS后会进行解密，然后进行我们要进行的操作，之后将数据再加密打包返回，返回的过程中同样不会被防火墙发现IP地址和数据内容有问题。我们在本地进行解密后就可以得到想要的结果。<br>
但是，这个过程并不是天衣无缝的，GFW防火墙不只是被动探测，他也会主动向你的VPS发送数据进行检测，如果你使用的shadowsocks协议有漏洞，那么恭喜你，你又寄b了。<br>
Recap：DNS污染、SNI阻断、TCP重置、传统VPN的问题、shadowsocks</p>
<h2 id="创建vps与ss节点搭建">创建VPS与SS节点搭建</h2>
<p>自建节点的具体过程请自行上网查找，在这里我使用vultr购买了VPS，通过shadowsocks建立代理，之后使用了BBR和Kcptun进行加速。</p>
</div></article><aside class="toc"><h3>Table of contents</h3><nav id="toc"></nav></aside></main><footer class="site-footer"><div class="container"><p>© 2025 Zhang Shoufeng</p></div></footer><script src="/js/minimalfolio.js"></script><script>(function(){
  const content = document.querySelector('.post-content');
  const toc = document.getElementById('toc');
  if(!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  const ul = document.createElement('ul');
  headings.forEach(function(h){
    const id = h.id || h.textContent.trim().toLowerCase().replace(/[^a-z0-9\s]/g,'').replace(/\s+/g,'-');
    h.id = id;
    const li = document.createElement('li');
    li.className = h.tagName.toLowerCase();
    const a = document.createElement('a');
    a.href = '#' + id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  toc.appendChild(ul);
})();</script></body></html>