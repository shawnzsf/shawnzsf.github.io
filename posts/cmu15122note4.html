<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>CMU 15122：Transitioning to C | Shoufeng's Blog</title><link rel="stylesheet" href="/css/minimalfolio.css"><meta name="generator" content="Hexo 7.0.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><header class="site-header"><div class="container"><a class="logo" href="/">Shoufeng's Blog</a><nav class="main-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/categories/">Categories</a></li></ul></nav></div></header><main class="container post"><article><h1 class="post-title">CMU 15122：Transitioning to C</h1><p class="post-meta">2024-07-29</p><div class="post-content"><h1 id="graph-representation">Graph Representation</h1>
<h2 id="graph-interface">Graph Interface</h2>
<p>Graph是Undirected的（15122定义），也就是说对于vertex A和B，BA和AB是一条edge。我们将graph表示成一个data structure，其中vertex定义为无符号整数。那么一个基本的graph interface可以如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned int vertex;</span><br><span class="line">typedef struct graph_header *graph_t;</span><br><span class="line"></span><br><span class="line">graph_t graph_new(unsigned int numvert);</span><br><span class="line">//@ensures \result != NULL;</span><br><span class="line"></span><br><span class="line">void graph_free(graph_t G);</span><br><span class="line">//@requires G != NULL;</span><br><span class="line"></span><br><span class="line">unsigned int graph_size(graph_t G);</span><br><span class="line">//@requires G != NULL;</span><br><span class="line"></span><br><span class="line">bool graph_hasedge(graph_t G, vertex v, vertex w);</span><br><span class="line">//@requires G != NULL;</span><br><span class="line">//@requires v &lt; graph_size(G) &amp;&amp; w &lt; graph_size(G);</span><br><span class="line"></span><br><span class="line">void graph_addedge(graph_t G, vertex v, vertex w);</span><br><span class="line">//@requires G != NULL;</span><br><span class="line">//@requires v &lt; graph_size(G) &amp;&amp; w &lt; graph_size(G);</span><br><span class="line">//@requires v != w &amp;&amp; !graph_hasedge(G, v, w);</span><br><span class="line"></span><br><span class="line">typedef struct neighbor_header *neighbors_t;</span><br><span class="line"></span><br><span class="line">neightbors_t graph_get_neighbors(graph_t G, vertex v);</span><br><span class="line">//@requires G != NULL &amp;&amp; v &lt; graph_size(G);</span><br><span class="line">//@ensures \result != NULL;</span><br><span class="line"></span><br><span class="line">bool graph_hasmore_neighbors(neighbors_t nbors);</span><br><span class="line">//@requires nbors != NULL;</span><br><span class="line"></span><br><span class="line">vertex graph_next_neighbor(neighbors_t nbors);</span><br><span class="line">//@requires nbors != NULL;</span><br><span class="line">//@requires graph_hasmore_neighbors(nbors);</span><br><span class="line"></span><br><span class="line">void graph_free_neighbors(neighbors_t nbors);</span><br><span class="line">//@requires nbors != NULL;</span><br></pre></td></tr></table></figure>
<p>我们通过graph_hasmore_neighbors和graph_next_neighbors来检查或者获取某个vertex的相邻vertex。我们可以通过多种数据结构实现上面的interface，一个有e条边的graph可以被链表或者edge的数组来表示。在链表实现中，添加一个edge的时间复杂度是O(1)，因为可以直接在链表前面接上。但是检查某一个edge是否存在需要O(e)的复杂度因为要遍历整个graph。获取某个节点的相邻节点同样需要O(e)的复杂度(Worst case)。使用哈希表和自平衡二分树也可以实现graph，但是这里只涉及到使用adjacency matrices和adjacency lists的graph实现。</p>
<h2 id="adjacency-matrices">Adjacency Matrices</h2>
<p>我们可以使用一个二维数组储存两个节点之间是否存在edge，这样的表示方法在这里被称为Adjacency Matrices。假设我们有节点B(=1)和节点D(=3)，我们检查两个节点之间是否存在edge的方法就是看二维数组的row 1，column 3。在一个不区分方向的图中，数组的右上半边是左下的镜像。因为edge的关系是对称的。因为我们不允许一个node使用edge链接自己，所以这个matrix的对角线是空的。</p>
<p>Adjacency Matrices的实现需要很多空间。对于一个有v个节点的graph我们需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(v^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的复杂度来分配内存。但是，使用改方法的好处是添加edge和检查edge的操作都是O(1)复杂度。</p>
<p>假如一个graph有0到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>v</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{v(v-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个节点数v，并且多数edge存在，那么总edge数和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">v^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>成比例关系，我们说这样的graph是dense的。对于dense graph，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(e) = O(v^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因此adjacency matrices是表示其的较好办法。因为存储其的空间并不比linked list多，但是操作更快。</p>
<h2 id="adjacency-lists">Adjacency Lists</h2>
<p>我们将dense graph的对立称作sparse graph。Adjacency lists适合作为sparse graph的实现。在这个实现当中，我们有一个类似于哈希表的一维数组，每一个vertex都在数组中有一个位置，并且数组中的每一个元素包含所有其他和该vertex相连的链表。</p>
<p>这个实现需要O(v + e)的空间来存储有v个vertex和e个edge的graph。也可以被写作O(max(v, e))。添加一个edge需要的时间是constant，但是lookup某一个edge需要的时间是O(min(v, e))，因为min(v-1, e)是每一个adjacency list的最大长度。在adjacency list实现里面寻找一个neighbor的时间是O(1)。</p>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">typedef struct adjlist_node adjlist</span><br><span class="line">struct adjlist_node&#123;</span><br><span class="line">  vertex vert;</span><br><span class="line">  adjlist *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct graph_header graph;</span><br><span class="line">struct graph_header&#123;</span><br><span class="line">  unsigned int size;</span><br><span class="line">  adjlist **adj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_vertex(graph *G, vertex v)&#123;</span><br><span class="line">  REQUIRES(G != NULL);</span><br><span class="line">  return v &lt; G-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_in(adjlist *p, vertex v)&#123;</span><br><span class="line">  while(p != NULL)&#123;</span><br><span class="line">    if(p-&gt;vert == v) return true;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_graph(graph *G)&#123;</span><br><span class="line">  if(G == NULL) return false;</span><br><span class="line">  if(G-&gt;adj == NULL) return false;</span><br><span class="line">  for(unsigned int i = 0; i &lt; G-&gt;size; i++)&#123;</span><br><span class="line">    if(!is_acyclic(G-&gt;adj[i])) return false;</span><br><span class="line">    for(adjlist *p = G-&gt;adj[i]; p != NULL; p = p-&gt;next)&#123;</span><br><span class="line">      if(p-&gt;vert == i || !(is_vertex(G, p-&gt;vert))) return false;</span><br><span class="line">      if(!is_in(G-&gt;adj[p-&gt;vert], i)) return false;</span><br><span class="line">      if(is_in(p-&gt;next, p-&gt;vert)) return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph *graph_new(unsigned int size)&#123;  </span><br><span class="line">  graph *G = xmalloc(sizeof(graph));</span><br><span class="line">  G-&gt;size = size;</span><br><span class="line">  G-&gt;adj = xcalloc(size, sizeof(adjlist*));</span><br><span class="line">  ENSURES(is_graph(G));</span><br><span class="line">  return G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool graph_hasedge(graph *G, vertex v, vertex w)&#123;</span><br><span class="line">  REQUIRES(is_graph(G) &amp;&amp; is_vertex(G, v) &amp;&amp; is_vertex(G, w));</span><br><span class="line">  for(adjlist *L = G-&gt;adj[v]; L != NULL; L = L-&gt;next)&#123;</span><br><span class="line">    if(L-&gt;vert = w) return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void graph_addedge(graph *G, vertex v, vertex w)&#123;</span><br><span class="line">  REQUIRES(is_graph(G) &amp;&amp; is_vertex(G, v) &amp;&amp; is_vertex(G, w));</span><br><span class="line">  REQUIRES(v != w &amp;&amp; !graph_hasedge(G, v, w));</span><br><span class="line"></span><br><span class="line">  adjlist *L;</span><br><span class="line">  L = xmalloc(sizeof(adjlist));</span><br><span class="line">  L-&gt;vert = w;</span><br><span class="line">  L-&gt;next = G-&gt;adj[v];</span><br><span class="line">  G-&gt;adj[v] = L;</span><br><span class="line"></span><br><span class="line">  L = xmalloc(sizeof(adjlist));</span><br><span class="line">  L-&gt;vert = v;</span><br><span class="line">  L-&gt;next = G-&gt;adj[w];</span><br><span class="line">  G-&gt;adj[w] = L;</span><br><span class="line"></span><br><span class="line">  ENSURES(is_graph(G));</span><br><span class="line">  ENSURES(graph_hasedge(G, v, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct neighbor_header&#123;</span><br><span class="line">  adjlist *next_neighbor;</span><br><span class="line">&#125;</span><br><span class="line">typedef struct neighbor_header neighbors;</span><br><span class="line"></span><br><span class="line">neighbors *graph_get_neighbors(graph *G, vertex v)&#123;</span><br><span class="line">  REQUIRES(is_graph(G) &amp;&amp; is_vertex(G, v));</span><br><span class="line">  neighbors *nbors = xmalloc(sizeof(neighbors));</span><br><span class="line">  nbors-&gt;next_neighbor = G-&gt;adj[v];</span><br><span class="line">  ENSURES(is_neighbors(nbors));</span><br><span class="line">  return nbors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool graph_hasmore_neighbors(neighbors *nbors)&#123;</span><br><span class="line">  REQUIRES(is_neighbors(nbors));</span><br><span class="line">  return nbors-&gt;next_neighbor != NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vertex graph_next_neighbor(neighbors *nbors)&#123;</span><br><span class="line">  REQUIRES(is_neighbors(nbors));</span><br><span class="line">  REQUIRES(graph_hasmore_neighbors(nbors));</span><br><span class="line"></span><br><span class="line">  vertex v = nbors-&gt;next_neighbor-&gt;vert;</span><br><span class="line">  nbors-&gt;next_neighbor = nbors-&gt;next_neighbor-&gt;next;</span><br><span class="line">  return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void graph_free_neighbors(neighbors *nbors)&#123;</span><br><span class="line">    free(nbors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article><aside class="toc"><h3>Table of contents</h3><nav id="toc"></nav></aside></main><footer class="site-footer"><div class="container"><p>© 2025 Zhang Shoufeng</p></div></footer><script src="/js/minimalfolio.js"></script><script>(function(){
  const content = document.querySelector('.post-content');
  const toc = document.getElementById('toc');
  if(!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  const ul = document.createElement('ul');
  headings.forEach(function(h){
    const id = h.id || h.textContent.trim().toLowerCase().replace(/[^a-z0-9\s]/g,'').replace(/\s+/g,'-');
    h.id = id;
    const li = document.createElement('li');
    li.className = h.tagName.toLowerCase();
    const a = document.createElement('a');
    a.href = '#' + id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  toc.appendChild(ul);
})();</script></body></html>