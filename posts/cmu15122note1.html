<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>CMU 15122: Contracts | Shoufeng's Blog</title><link rel="stylesheet" href="/css/minimalfolio.css"><meta name="generator" content="Hexo 7.0.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><header class="site-header"><div class="container"><a class="logo" href="/">Shoufeng's Blog</a><nav class="main-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/categories/">Categories</a></li></ul></nav></div></header><main class="container post"><article><h1 class="post-title">CMU 15122: Contracts</h1><p class="post-meta">2024-06-27</p><div class="post-content"><p>CMU15122开头部分讲的内容都是关于如何编写Contracts来保证程序的正确性和安全性，以及利用Contract对程序进行验证。本文简单梳理其中引出的概念。</p>
<h2 id="contract">Contract</h2>
<p>c0中有四种Contract：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- //@requires exp; checked before function execution</span><br><span class="line">- //@ensures exp; checked function returns</span><br><span class="line">- //@assert exp; checked wherever it is</span><br><span class="line">- //@loop_invariant exp; checked before the loop guard</span><br></pre></td></tr></table></figure>
<p>其中@requires旨在检查函数的precondition是否满足，@ensures旨在检查postcondition是否满足。其中@ensures中可以使用\result来表示函数返回值。@loop_invariant通常检查的是循环中几个变量构成的常量表达式，其在每轮iteration检查循环条件是否满足时被检查，并且只能在循环开头写。@assert即在程序任意位置检查附上表达式的真假。</p>
<h2 id="proving-function-correctness">Proving Function Correctness</h2>
<ul>
<li>
<p>INITialization：证明loop invariant在进入循环之前满足条件。允许使用循环前的代码以及preconditions进行证明。</p>
</li>
<li>
<p>PREServation：证明任意循环后loop invariant的表达式都为真。可以使用循环内部代码，loop invariant(因为INIT已经验证了进入循环时表达式为真，因此可以假设循环开始时为真)，以及loop guard。</p>
</li>
<li>
<p>EXIT：证明经过循环postcondition为真。可以使用loop guard，loop invariant以及循环之后的代码进行证明。需要注意的是虽然可使用loop guard以及loop invariant，但无法使用循环内部代码。</p>
</li>
<li>
<p>TERMination：证明循环可终止。Operational reasoning(Expression strictly decreases at each iteration of the loop and can never become smaller than the constant)。</p>
</li>
</ul>
<h3 id="template">Template</h3>
<p>Loop invariant/… on line x (…):<br>
Assume:<br>
To show:<br>
A.       by<br>
B.       by<br>
C.       by<br>
D.       by</p>
<h2 id="point-to-reasoning">Point-to Reasoning</h2>
<p>Point-to Reasoning is drawing conclusions about what we know to be true by pointing to specific lines of code that justify them.</p>
<p>Examples:</p>
<ul>
<li>Boolean conditions
<ul>
<li>condition of an if statement in the “then” branch</li>
<li>negation of the condition of an if statement in the “else” branch</li>
<li>loop guard inside the body of a loop</li>
<li>negation of the loop guard after the loop</li>
</ul>
</li>
<li>Contract annotations
<ul>
<li>preconditions of the current function</li>
<li>postconditions of a function just called</li>
<li>loop invariant inside the loop body</li>
<li>loop invariant after the loop</li>
<li>earlier fully justified assertions</li>
</ul>
</li>
<li>Math
<ul>
<li>laws of logic</li>
<li>some laws of arithmetic</li>
</ul>
</li>
<li>Value of variables right after an assignment</li>
</ul>
</div></article><aside class="toc"><h3>Table of contents</h3><nav id="toc"></nav></aside></main><footer class="site-footer"><div class="container"><p>© 2025 Zhang Shoufeng</p></div></footer><script src="/js/minimalfolio.js"></script><script>(function(){
  const content = document.querySelector('.post-content');
  const toc = document.getElementById('toc');
  if(!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  const ul = document.createElement('ul');
  headings.forEach(function(h){
    const id = h.id || h.textContent.trim().toLowerCase().replace(/[^a-z0-9\s]/g,'').replace(/\s+/g,'-');
    h.id = id;
    const li = document.createElement('li');
    li.className = h.tagName.toLowerCase();
    const a = document.createElement('a');
    a.href = '#' + id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  toc.appendChild(ul);
})();</script></body></html>