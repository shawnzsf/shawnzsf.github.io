<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Get deeper in SRAM | Shoufeng's Blog</title><link rel="stylesheet" href="/css/minimalfolio.css"><meta name="generator" content="Hexo 7.0.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><header class="site-header"><div class="container"><a class="logo" href="/">Shoufeng's Blog</a><nav class="main-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/categories/">Categories</a></li></ul></nav></div></header><main class="container post"><article><h1 class="post-title">Get deeper in SRAM</h1><p class="post-meta">2023-08-03</p><div class="post-content"><h2 id="theory">Theory</h2>
<p>RAM(Random Access Memory)具有如下两个特点：</p>
<ul>
<li>易变，断电时易失数据。</li>
<li>读写行为快，速度与数据存储位置无关。</li>
</ul>
<p>RAM又有如下两个分类：</p>
<ul>
<li>DRAM (Dynamic Random Access Memory)</li>
<li>SRAM (Static Random Access Memory)</li>
</ul>
<p>DRAM由一个电容器(capacitor)和一个晶体管(transistor)构成。因为电容器的缺陷，DRAM经常需要被刷新，因此DRAM要远比SRAM慢。</p>
<p>因此SRAM经常被用作缓存(cache)，而DRAM因为相对便宜且密度大主要作为处理器内存。</p>
<p>一个SRAM中有六个晶体管，可以存储一个bit的数据，每个bit存储在四个晶体管上，因此有两个重合部分。</p>
<p>SRAM小结：</p>
<ul>
<li>最快的存储器</li>
<li>由6个晶体管构成</li>
<li>不需要被刷新</li>
<li>密度更低，平方面积存储能力更差，因为一个单元上的电路更多</li>
</ul>
<p>文章主要讨论异步(asynchronous) SRAM。</p>
<h2 id="hands-on">Hands On</h2>
<p>Cmod A7 开发板集成了SRAM，其特点如下：</p>
<ul>
<li>512KB</li>
<li>19个地址信号</li>
<li>8个双向数据信号</li>
<li>3个控制信号
<ul>
<li>三个控制信号分别是CE，OE和WE，活跃度都很低</li>
<li>ce_n (chip enable)：控制芯片是否被启用</li>
<li>we_n (write enable): 控制写入操作</li>
<li>oe_n (output enable): 控制读出操作</li>
</ul>
</li>
<li>访问时间10ns</li>
<li>数据总线(data bus)为8 bit宽</li>
</ul>
<p>开发板的读操作涉及到11个时间参数，其中的6个如下：</p>
<ul>
<li>trc：读周期时间(read cycle time)，两个读操作的最短间隔，几乎与tAA相等。</li>
<li>tAA：地址访问时间(address access time)，地址变化后获取稳定数据的时间。</li>
<li>tOHA：输出保持时间(output hold time)，地址变化后输出数据仍然有效的时间。</li>
<li>tDOE：输出使能访问时间(output enable access time)，激活oen后获取有效数据所需的时间。</li>
<li>tHZOE：输出使能到high-Z时间(output enable to high-Z time)，oe_n去激活后三态缓冲器进入高阻抗状态的时间。</li>
<li>tLZOE：输出使能到low-Z时间(output enable to low-Z time)，oe_n被激活后三态缓冲器离开高阻抗状态的时间。请注意，即使输出不再处于高阻抗状态，数据仍然无效。</li>
</ul>
<p>开发板的写操作涉及到的时间参数如下：</p>
<ul>
<li>twc：写周期时间(write cycle time)，两个写操作的最短间隔。</li>
<li>tSA：地址建立时间(address setup time)，在we_n被激活之前，地址必须稳定的最短时间。</li>
<li>tHA：地址保持时间(address hold time)，去激活we_n后地址必须稳定的最短时间。</li>
<li>tPWE1：写使能脉冲宽度(we_n pulse width)，we_n必须断言的最小时间。</li>
<li>tso：数据建立时间(data setup time)，在锁存沿(we_n从0移动到1的上升沿)之前，数据必须保持稳定的最短时间。</li>
<li>tHD：数据保持时间，数据在锁存沿后必须保持稳定的最短时间。</li>
</ul>
<h2 id="controller">Controller</h2>
<p>为了成功执行一个读或写操作，断言地址、数据和控制信号的顺序是很重要的，并且需要确定他们保持一段时间的稳定。为了实现这些并且接入SRAM，我们用一个存储控制器(Memory Controller)。</p>
<h3 id="controller-using-verilog">Controller using Verilog</h3>
<p>一个非常简单和基本的SRAM控制器的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module basic_sram_controller(</span><br><span class="line"></span><br><span class="line">  input wire clk,                        //  Clock signal</span><br><span class="line"></span><br><span class="line">  input wire rw,                         //  With this signal, we select reading or writing operation</span><br><span class="line">  input wire [18:0] addr,                //  Address bus</span><br><span class="line">  input wire [7:0] data_f2s,             //  Data to be writteb in the SRAM</span><br><span class="line">  </span><br><span class="line">  output reg [7:0] data_s2f_r,           //  It is the 8-bit registered data retrieved from the SRAM (the -s2f suffix stands for SRAM to FPGA)</span><br><span class="line">  output wire [18:0] ad,                 //  Address bus</span><br><span class="line">  output wire we_n,                      //  Write enable (active-low)</span><br><span class="line">  output wire oe_n,                      //  Output enable (active-low)</span><br><span class="line"></span><br><span class="line">  inout wire [7:0] dio_a,                //  Data bus</span><br><span class="line">  output wire ce_a_n                     //  Chip enable (active-low). Disables or enables the chip.</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assign ce_a_n = 1&#x27;b0;</span><br><span class="line">  assign oe_n = 1&#x27;b0;</span><br><span class="line">  assign we_n = rw;</span><br><span class="line">  assign ad = addr;</span><br><span class="line">  </span><br><span class="line">  assign dio_a = (rw == 1&#x27;b1)? 8&#x27;hZZ : data_f2s;</span><br><span class="line">  </span><br><span class="line">  always @(posedge clk) begin</span><br><span class="line">    if (rw == 1&#x27;b1)</span><br><span class="line">      data_s2f_r &lt;= dio_a;</span><br><span class="line">  end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p>这种设计提供了较大的时间裕度，并且不施加任何严格的时间限制。它已在Cmod A7 FPGA板上进行了测试，该板具有12 MHz时钟输入，即周期为83.333纳秒。</p>
<p>ce_n(芯片使能信号)和oe_n(输出使能信号)一直处于激活状态。</p>
<p>我们对三态缓冲区使用三元运算符。注意，dio是一个双向总线。</p>
<p>下面是一个非常简单的仿真模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">specify					</span><br><span class="line">    specparam </span><br><span class="line">    Twp = 8,	</span><br><span class="line">    Tdw = 6,				</span><br><span class="line">    Tdh = 0;				</span><br><span class="line">    $width (negedge we_n, Twp);			</span><br><span class="line">    $setup (data, posedge we_n, Tdw);	</span><br><span class="line">    $hold (posedge we_n, data, Tdh);	</span><br><span class="line">endspecify</span><br><span class="line">reg [7:0] sram [0:1024];</span><br><span class="line">always@(posedge we_n)</span><br><span class="line">    if (ce_n == 1&#x27;b0)  </span><br><span class="line">    sram[addr] &lt;= data;</span><br><span class="line">assign #10 data = (~ce_n &amp; ~oe_n) ? sram[addr] :  8&#x27;bz; </span><br></pre></td></tr></table></figure>
<p>接下来要构建一个可综合的设计来测试SRAM。对于测试SRAM的HDL设计，我们必须能够在任何特定地址中写入和读取任何数据。因此，重要的是要有一个终端来选择我们想要进行的操作，并输入任何所需的数据。要做到这一点，设计将需要以下模块:</p>
<ul>
<li>UART：向FPGA/PC发送或接受数据。</li>
<li>Debouncer：debounce reset button。</li>
<li>FSM: 控制设计中所有的信号和状态。</li>
<li>SRAM控制器</li>
</ul>
<p>原文章：<a target="_blank" rel="noopener" href="https://www.hackster.io/salvador-canas/a-practical-introduction-to-sram-memories-using-an-fpga-i-3f3992">https://www.hackster.io/salvador-canas/a-practical-introduction-to-sram-memories-using-an-fpga-i-3f3992</a></p>
</div></article><aside class="toc"><h3>Table of contents</h3><nav id="toc"></nav></aside></main><footer class="site-footer"><div class="container"><p>© 2025 Zhang Shoufeng</p></div></footer><script src="/js/minimalfolio.js"></script><script>(function(){
  const content = document.querySelector('.post-content');
  const toc = document.getElementById('toc');
  if(!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  const ul = document.createElement('ul');
  headings.forEach(function(h){
    const id = h.id || h.textContent.trim().toLowerCase().replace(/[^a-z0-9\s]/g,'').replace(/\s+/g,'-');
    h.id = id;
    const li = document.createElement('li');
    li.className = h.tagName.toLowerCase();
    const a = document.createElement('a');
    a.href = '#' + id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  toc.appendChild(ul);
})();</script></body></html>