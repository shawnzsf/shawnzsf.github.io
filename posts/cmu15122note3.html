<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>CMU 15122：Data Structures | Shoufeng's Blog</title><link rel="stylesheet" href="/css/minimalfolio.css"><meta name="generator" content="Hexo 7.0.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><header class="site-header"><div class="container"><a class="logo" href="/">Shoufeng's Blog</a><nav class="main-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/categories/">Categories</a></li></ul></nav></div></header><main class="container post"><article><h1 class="post-title">CMU 15122：Data Structures</h1><p class="post-meta">2024-07-17</p><div class="post-content"><h1 id="libraries">Libraries</h1>
<h2 id="overview">Overview</h2>
<p>通过使用库（libraries），程序可以复用已经编写好的代码，包括系统代码、过去编写的简单代码以及他人编写的复杂代码。库有助于隐藏不必要的细节，使代码更易于管理，并允许透明的改进。</p>
<p>Structure of a library:</p>
<ul>
<li>接口（Interface）：列出了库导出的功能及其使用方法。</li>
<li>实现（Implementation）：实现接口中列出的功能的代码。</li>
<li>文档（Documentation）：解释库中功能的作用。</li>
</ul>
<p>在编写应用程序代码时，开发者能且只能使用接口中列出的功能，不依赖于实现。编译应用程序时，需要包含库的实现。库包含系统库作为编程语言的一部分，如C0的输入输出函数，和用户定义库**：由用户编写或从互联网下载，必须与应用程序一起编译。</p>
<p>就15122而言，库最重要的帮助是定义了新数据类型及其使用方法。通过接口定义类型和操作，使得实现可以透明地更改，而不影响使用该类型的应用程序。</p>
<h2 id="example-of-self-sorting-arrays-ssa">Example of Self-Sorting Arrays, SSA</h2>
<p>SSA是一个示例数据结构，类似于字符串数组，但具有报告长度的功能，并保证其元素是排序的。</p>
<ul>
<li><strong>接口内容</strong>：
<ol>
<li>自排序数组的类型（ssa_t），通常（xxx_t）是声明struct xxx后typedef该struct的指针。</li>
<li>操作SSA的库提供的函数，如创建新数组（“ssa_new”）、读取数组索引的值（“ssa_get”）、替换数组索引的值（“ssa_set”）、返回数组长度（“ssa_len”）。</li>
<li>每个操作的contracts，包括pre/postconditions。</li>
<li>Data structure invariant, 用于确保SSA的表示是有效的，如<code>is_ssa</code>函数，只在library implementation中使用，通常用在contract的pre/postcondition当中。</li>
</ol>
</li>
</ul>
<p>客户端代码只能通过接口与SSA交互，实现细节不对客户端透明。</p>
<h1 id="stack-and-queue">Stack and Queue</h1>
<h2 id="worklists">Worklists</h2>
<ul>
<li><strong>Worklists</strong>是一个数据结构家族，可以存储元素，并提供一种方法来检索它们。客户端可以添加元素到工作列表并从中检索元素，而不需要关心其实现方式。</li>
<li><strong>例子</strong>：待办事项列表、食堂排队、操作系统中的挂起进程，栈（Stacks），队列（Queues），优先队列（Priority Queues）。</li>
<li><strong>类型</strong>：
<ul>
<li>工作列表中的元素：字符串（string）</li>
<li>工作列表本身：类型为 <code>wl_t</code></li>
</ul>
</li>
<li><strong>操作</strong>：
<ul>
<li>添加元素：<code>wl_add</code></li>
<li>检索元素：<code>wl_retrieve</code></li>
<li>创建新的工作列表：<code>wl_new</code></li>
<li>检查工作列表是否为空：<code>wl_empty</code></li>
</ul>
</li>
</ul>
<h2 id="stacks">Stacks</h2>
<ul>
<li><strong>栈</strong>是一种工作列表，其中检索的是最后插入的元素。</li>
<li><strong>操作</strong>：
<ul>
<li>压栈（push）：在栈顶添加元素</li>
<li>出栈（pop）：从栈顶移除元素</li>
</ul>
</li>
</ul>
<h3 id="the-stack-interface">The Stack Interface</h3>
<ul>
<li><strong>栈接口</strong>：工作列表接口的名称变更版，并提供复杂度界限。</li>
<li><strong>操作</strong>：
<ul>
<li><code>stack_empty(stack_t S)</code>：检查栈是否为空，时间复杂度 O(1)</li>
<li><code>stack_new()</code>：创建一个新的空栈，时间复杂度 O(1)</li>
<li><code>push(stack_t S, string x)</code>：向栈中添加元素，时间复杂度 O(1)</li>
<li><code>pop(stack_t S)</code>：从栈中移除元素，时间复杂度 O(1)</li>
</ul>
</li>
</ul>
<h3 id="peeking-into-a-stack">Peeking into a Stack</h3>
<ul>
<li><strong>查看栈顶元素</strong>：编写一个客户端函数，返回栈顶元素但不移除它。</li>
<li><strong>实现</strong>：使用 <code>pop</code> 操作移除栈顶元素，然后使用 <code>push</code> 操作将其放回。</li>
</ul>
<h3 id="the-size-of-a-stack">The Size of a Stack</h3>
<ul>
<li><strong>栈的大小</strong>：编写一个客户端函数，返回栈中元素的数量。</li>
<li><strong>实现</strong>：通过 <code>pop</code> 操作计数元素，然后将它们压回栈中以恢复原始顺序。</li>
</ul>
<h3 id="sample-implementation">Sample implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">#use &lt;conio&gt;</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">/* Aux structure of linked lists */</span><br><span class="line">typedef struct list_node list;</span><br><span class="line">struct list_node &#123;</span><br><span class="line">  string data;</span><br><span class="line">  list* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_acyclic(list* start) &#123;</span><br><span class="line">  if (start == NULL) return true;</span><br><span class="line">  list* h = start-&gt;next;         // hare</span><br><span class="line">  list* t = start;               // tortoise</span><br><span class="line">  while (h != t) &#123;</span><br><span class="line">    if (h == NULL || h-&gt;next == NULL) return true;</span><br><span class="line">    h = h-&gt;next-&gt;next;</span><br><span class="line">    //@assert t != NULL; // hare is faster and hits NULL quicker</span><br><span class="line">    t = t-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  //@assert h == t;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* is_segment(start, end) will diverge if list is circular! */</span><br><span class="line">bool is_segment(list* start, list* end) &#123;</span><br><span class="line">  if (start == NULL) return false;</span><br><span class="line">  if (start == end) return true;</span><br><span class="line">  return is_segment(start-&gt;next, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Will run for ever if the segment is circular</span><br><span class="line">void print_segment(list* start, list* end)</span><br><span class="line">//requires start != NULL;</span><br><span class="line">&#123;</span><br><span class="line">  for (list* p = start; p != end; p = p-&gt;next) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, p-&gt;data);</span><br><span class="line">    if (p != end) printf(&quot;-&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Stacks */</span><br><span class="line"></span><br><span class="line">typedef struct stack_header stack;</span><br><span class="line">struct stack_header &#123;</span><br><span class="line">  list* top;</span><br><span class="line">  list* floor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void stack_print_unsafe(stack* S)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;[top] &quot;);</span><br><span class="line">  print_segment(S-&gt;top, S-&gt;floor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_stack(stack* S) &#123;</span><br><span class="line">  return S != NULL</span><br><span class="line">      &amp;&amp; is_acyclic(S-&gt;top)</span><br><span class="line">      &amp;&amp; is_segment(S-&gt;top, S-&gt;floor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stack_print_internal(stack* S)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">&#123;</span><br><span class="line">  stack_print_unsafe(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool stack_empty(stack* S)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">&#123;</span><br><span class="line">  return S-&gt;top == S-&gt;floor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack* stack_new()</span><br><span class="line">//@ensures is_stack(\result);</span><br><span class="line">//@ensures stack_empty(\result);</span><br><span class="line">&#123;</span><br><span class="line">  stack* S = alloc(stack);</span><br><span class="line">  list* l = alloc(list);</span><br><span class="line">  S-&gt;top = l;</span><br><span class="line">  S-&gt;floor = l;</span><br><span class="line">  return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(stack* S, string x)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">//@ensures is_stack(S);</span><br><span class="line">//@ensures !stack_empty(S);</span><br><span class="line">&#123;</span><br><span class="line">  list* l = alloc(list);</span><br><span class="line">  l-&gt;data = x;</span><br><span class="line">  l-&gt;next = S-&gt;top;</span><br><span class="line">  S-&gt;top = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string pop(stack* S)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">//@requires !stack_empty(S);</span><br><span class="line">//@ensures is_stack(S);</span><br><span class="line">&#123;</span><br><span class="line">  string e = S-&gt;top-&gt;data;</span><br><span class="line">  S-&gt;top = S-&gt;top-&gt;next;</span><br><span class="line">  return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stack_print(stack* S)</span><br><span class="line">//@requires is_stack(S);</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;TOP: &quot;);</span><br><span class="line">  for (list* l = S-&gt;top; l != S-&gt;floor; l = l-&gt;next) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, l-&gt;data);</span><br><span class="line">    if (l-&gt;next != S-&gt;floor) printf(&quot; | &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client type</span><br><span class="line">typedef stack* stack_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/******************************* Interface ******************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* stack_t;</span><br><span class="line"></span><br><span class="line">bool stack_empty(stack_t S)       /* O(1) */</span><br><span class="line">/*@requires S != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">stack_t stack_new()               /* O(1) */</span><br><span class="line">/*@ensures \result != NULL; @*/</span><br><span class="line">/*@ensures stack_empty(\result); @*/ ;</span><br><span class="line"></span><br><span class="line">void push(stack_t S, string x)    /* O(1) */</span><br><span class="line">/*@requires S != NULL; @*/</span><br><span class="line">/*@ensures !stack_empty(S); @*/ ;</span><br><span class="line"></span><br><span class="line">string pop(stack_t S)             /* O(1) */</span><br><span class="line">/*@requires S != NULL; @*/</span><br><span class="line">/*@requires !stack_empty(S); @*/ ;</span><br><span class="line"></span><br><span class="line">void stack_print(stack_t S)       /* O(n) */</span><br><span class="line">/*@requires S != NULL; @*/ ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="queues">Queues</h2>
<ul>
<li><strong>队列</strong>是一种工作列表，其中检索的是最早插入的元素。</li>
<li><strong>操作</strong>：
<ul>
<li><code>enqueue</code>：在队列尾部添加元素</li>
<li><code>dequeue</code>：从队列头部移除元素</li>
</ul>
</li>
</ul>
<h3 id="the-queue-interface">The Queue Interface</h3>
<ul>
<li><strong>队列接口</strong>：类似于工作列表接口，名称变更。</li>
<li><strong>操作</strong>：
<ul>
<li><code>queue_empty(queue_t S)</code>：检查队列是否为空，时间复杂度 O(1)</li>
<li><code>queue_new()</code>：创建一个新的空队列，时间复杂度 O(1)</li>
<li><code>enq(queue_t S, string x)</code>：向队列中添加元素，时间复杂度 O(1)</li>
<li><code>deq(queue_t S)</code>：从队列中移除元素，时间复杂度 O(1)</li>
</ul>
</li>
</ul>
<h3 id="copying-a-queue">Copying a Queue</h3>
<ul>
<li><strong>复制队列</strong>：编写一个客户端函数，返回队列的深拷贝，即一个新队列，包含与原队列相同顺序的元素。</li>
</ul>
<h3 id="sample-implementation">Sample implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">#use &lt;conio&gt;</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">/* Aux structure of linked lists */</span><br><span class="line">typedef struct list_node list;</span><br><span class="line">struct list_node &#123;</span><br><span class="line">  string data;</span><br><span class="line">  list* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_acyclic(list* start) &#123;</span><br><span class="line">  if (start == NULL) return true;</span><br><span class="line">  list* h = start-&gt;next;         // hare</span><br><span class="line">  list* t = start;               // tortoise</span><br><span class="line">  while (h != t) &#123;</span><br><span class="line">    if (h == NULL || h-&gt;next == NULL) return true;</span><br><span class="line">    h = h-&gt;next-&gt;next;</span><br><span class="line">    //@assert t != NULL; // hare is faster and hits NULL quicker</span><br><span class="line">    t = t-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  //@assert h == t;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* is_segment(start, end) will diverge if list is circular! */</span><br><span class="line">// Recursive version</span><br><span class="line">bool is_segment(list* start, list* end) &#123;</span><br><span class="line">  if (start == NULL) return false;</span><br><span class="line">  if (start == end) return true;</span><br><span class="line">  return is_segment(start-&gt;next, end);</span><br><span class="line">&#125;</span><br><span class="line">// Iterative version using a while loop</span><br><span class="line">bool is_segmentB(list* start, list* end) &#123;</span><br><span class="line">  list* l = start;</span><br><span class="line">  while (l != NULL) &#123;</span><br><span class="line">    if (l == end) return true;</span><br><span class="line">    l = l-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">// Iterative version using a for loop</span><br><span class="line">bool is_segmentC(list* start, list* end) &#123;</span><br><span class="line">  for (list* p = start; p != NULL; p = p-&gt;next) &#123;</span><br><span class="line">    if (p == end) return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Will run for ever if the segment is circular</span><br><span class="line">void print_segment(list* start, list* end)</span><br><span class="line">//requires start != NULL;</span><br><span class="line">&#123;</span><br><span class="line">  for (list* p = start; p != end; p = p-&gt;next) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, p-&gt;data);</span><br><span class="line">    if (p != end) printf(&quot;-&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Queues */</span><br><span class="line"></span><br><span class="line">typedef struct queue_header queue;</span><br><span class="line">struct queue_header &#123;</span><br><span class="line">  list* front;</span><br><span class="line">  list* back;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void queue_print_unsafe(queue* Q)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;[front] &quot;);</span><br><span class="line">  print_segment(Q-&gt;front, Q-&gt;back);</span><br><span class="line">  printf(&quot; [back]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_queue(queue* Q) &#123;</span><br><span class="line">  return Q != NULL</span><br><span class="line">      &amp;&amp; is_acyclic(Q-&gt;front)</span><br><span class="line">      &amp;&amp; is_segment(Q-&gt;front, Q-&gt;back);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_queue_internal(queue* Q)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">&#123;</span><br><span class="line">  queue_print_unsafe(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool queue_empty(queue* Q)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">&#123;</span><br><span class="line">  return Q-&gt;front == Q-&gt;back;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue* queue_new()</span><br><span class="line">//@ensures is_queue(\result);</span><br><span class="line">//@ensures queue_empty(\result);</span><br><span class="line">&#123;</span><br><span class="line">  queue* Q = alloc(queue);</span><br><span class="line">  list* l = alloc(list);</span><br><span class="line">  Q-&gt;front = l;</span><br><span class="line">  Q-&gt;back = l;</span><br><span class="line">  return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void enq(queue* Q, string s)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">//@ensures is_queue(Q);</span><br><span class="line">//@ensures !queue_empty(Q);</span><br><span class="line">&#123;</span><br><span class="line">  list* l = alloc(list);</span><br><span class="line">  Q-&gt;back-&gt;data = s;</span><br><span class="line">  Q-&gt;back-&gt;next = l;</span><br><span class="line">  Q-&gt;back = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string deq(queue* Q)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">//@requires !queue_empty(Q);</span><br><span class="line">//@ensures is_queue(Q);</span><br><span class="line">&#123;</span><br><span class="line">  string s = Q-&gt;front-&gt;data;</span><br><span class="line">  Q-&gt;front = Q-&gt;front-&gt;next;</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void queue_print(queue* Q)</span><br><span class="line">//@requires is_queue(Q);</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;FRONT: &quot;);</span><br><span class="line">  for (list* l = Q-&gt;front; l != Q-&gt;back; l = l-&gt;next) &#123;</span><br><span class="line">    printf(&quot;%s&quot;, l-&gt;data);</span><br><span class="line">    if (l-&gt;next != Q-&gt;back) printf(&quot; &lt;&lt; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot; :BACK&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client type</span><br><span class="line">typedef queue* queue_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/******************************* Interface ******************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* queue_t;</span><br><span class="line"></span><br><span class="line">bool queue_empty(queue_t Q)       /* O(1) */</span><br><span class="line">/*@requires Q != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">queue_t queue_new()               /* O(1) */</span><br><span class="line">/*@ensures \result != NULL; @*/</span><br><span class="line">/*@ensures queue_empty(\result); @*/ ;</span><br><span class="line"></span><br><span class="line">void enq(queue_t Q, string e)     /* O(1) */</span><br><span class="line">/*@requires Q != NULL; @*/</span><br><span class="line">/*@ensures !queue_empty(Q); @*/ ;</span><br><span class="line"></span><br><span class="line">string deq(queue_t Q)             /* O(1) */</span><br><span class="line">/*@requires Q != NULL; @*/</span><br><span class="line">/*@requires !queue_empty(Q); @*/ ;</span><br><span class="line"></span><br><span class="line">void queue_print(queue_t Q)       /* O(n) */</span><br><span class="line">/*@requires Q != NULL; @*/ ;</span><br></pre></td></tr></table></figure>
<h1 id="linked-lists">Linked lists</h1>
<p>链表是一种使用指针连接元素的数据结构，每个元素包含数据和指向下一个元素的指针。节点（Node）是链表的基本单元，包含数据和指向下一个节点的指针。</p>
<p>链表的递归类型：struct list_node { int data; list* next; }。链表的头指针指向链表的第一个节点。：<br>
在链表头部插入：时间复杂度 O(1)。在链表尾部插入：时间复杂度 O(n)，需要遍历整个链表。<br>
从链表头部删除：时间复杂度 O(1)。从链表尾部删除：时间复杂度 O(n)，需要遍历整个链表。</p>
<p>龟兔算法（Tortoise and Hare Algorithm）：使用两个指针（一个慢指针，一个快指针）来检测链表中是否存在循环。</p>
<p>使用链表可以实现Stack和Queue。</p>
<p>数组（未排序）：</p>
<ul>
<li>优点：O(1) 访问时间，内置的自适应大小。</li>
<li>缺点：固定大小，插入和删除操作时间复杂度为 O(n)。<br>
链表：</li>
<li>优点：自适应大小，O(1) 插入和删除操作（给定正确的指针）。</li>
<li>缺点：O(n) 访问时间，没有特殊的语法。</li>
</ul>
<h1 id="unbounded-array">Unbounded Array</h1>
<p>理解Unbounded Array(UBA)可能需要一些context。我们知道访问Array的复杂度是O(1)，并且我们在分配内存的时候赋予其固定长度。访问链表的复杂度是O(n)，但是其size是可变的。而UBA则结合了这两种结构的优势，提供了O(1)的访问复杂度，并且在数组满时扩张成更大的数组。</p>
<h2 id="interface">Interface</h2>
<ul>
<li>uba_len(uba_t A)：获取数组长度，时间复杂度 O(1)。</li>
<li>uba_new(int size)：创建一个新的无界数组，时间复杂度 O(size)。</li>
<li>uba_get(uba_t A, int i)：获取数组中索引为i的元素，时间复杂度 O(1)。</li>
<li>uba_set(uba_t A, int i, string x)：设置数组中索引为i的元素为x，时间复杂度 O(1)。</li>
<li>uba_add(uba_t A, string x)：在数组末尾添加元素x，时间复杂度 O(1)（摊销复杂度）。</li>
<li>uba_rem(uba_t A)：移除并返回数组的最后一个元素，时间复杂度 O(1)（摊销复杂度）。</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>数据结构：使用一个结构体uba_header来表示无界数组，包含数组的长度（size）、容量（limit）和数据（data）。<br>
扩容策略：当数组满时，通过创建一个更大的数组并将元素复制过去来实现扩容。</p>
<h3 id="sample-implementation">Sample Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">#use &lt;util&gt;</span><br><span class="line">#use &lt;string&gt;</span><br><span class="line">#use &lt;conio&gt;</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">typedef struct uba_header uba;</span><br><span class="line">struct uba_header &#123;</span><br><span class="line">  int size;          // 0 &lt;= size &amp;&amp; size &lt; limit</span><br><span class="line">  int limit;         // 0 &lt; limit</span><br><span class="line">  string[] data;     // \length(data) == limit</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Internal debugging function that prints an UBA without checking contracts</span><br><span class="line">// (useful to debug representation invariant issues)</span><br><span class="line">void uba_print_unsafe(uba* A)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;UBA limit=%d; length=%d; data=[&quot;, A-&gt;limit, A-&gt;size);</span><br><span class="line">  for (int i = 0; i &lt; A-&gt;limit; i++)</span><br><span class="line">  //@loop_invariant 0 &lt;= i &amp;&amp; i &lt;= A-&gt;limit;</span><br><span class="line">  &#123;</span><br><span class="line">    if (i &lt; A-&gt;size)</span><br><span class="line">      printf(&quot;%s&quot;, A-&gt;data[i]);</span><br><span class="line">    else</span><br><span class="line">      printf(&quot;X&quot;);</span><br><span class="line">    if (i &lt; A-&gt;limit-1) &#123;</span><br><span class="line">      if (i == A-&gt;size-1) printf(&quot; | &quot;);</span><br><span class="line">      else printf(&quot;, &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_array_expected_length(string[] A, int length) &#123;</span><br><span class="line">  //@assert \length(A) == length;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_uba(uba* A) &#123;</span><br><span class="line">  return A != NULL</span><br><span class="line">      &amp;&amp; 0 &lt;= A-&gt;size &amp;&amp; A-&gt;size &lt; A-&gt;limit</span><br><span class="line">      &amp;&amp; is_array_expected_length(A-&gt;data, A-&gt;limit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Internal debugging function that prints an SSA</span><br><span class="line">// (useful to spot bugs that do not invalidate the representation invariant)</span><br><span class="line">void uba_print_internal(uba* A)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  uba_print_unsafe(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Implementation of exported functions</span><br><span class="line">int uba_len(uba* A)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@ensures 0 &lt;= \result &amp;&amp; \result &lt; \length(A-&gt;data);</span><br><span class="line">&#123;</span><br><span class="line">  return A-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string uba_get(uba* A, int i)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@requires 0 &lt;= i &amp;&amp; i &lt; uba_len(A);</span><br><span class="line">&#123;</span><br><span class="line">  return A-&gt;data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uba_set(uba* A, int i, string x)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@requires 0 &lt;= i &amp;&amp; i &lt; uba_len(A);</span><br><span class="line">//@ensures is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  A-&gt;data[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uba* uba_new(int size)</span><br><span class="line">//@requires 0 &lt;= size;</span><br><span class="line">//@ensures is_uba(\result);</span><br><span class="line">//@ensures uba_len(\result) == size;</span><br><span class="line">&#123;</span><br><span class="line">  uba* A = alloc(uba);</span><br><span class="line">  int limit = size == 0 ? 1 : size*2;</span><br><span class="line">  A-&gt;data = alloc_array(string, limit);</span><br><span class="line">  A-&gt;size = size;</span><br><span class="line">  A-&gt;limit = limit;</span><br><span class="line"></span><br><span class="line">  return A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uba_resize(uba* A, int new_limit)</span><br><span class="line">/* A may not be a valid array since A-&gt;size == A-&gt;limit is possible! */</span><br><span class="line">//@requires A != NULL;</span><br><span class="line">//@requires 0 &lt;= A-&gt;size &amp;&amp; A-&gt;size &lt; new_limit;</span><br><span class="line">//@requires \length(A-&gt;data) == A-&gt;limit;</span><br><span class="line">//@ensures is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  string[] B = alloc_array(string, new_limit);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; A-&gt;size; i++)</span><br><span class="line">    //@loop_invariant 0 &lt;= i;</span><br><span class="line">    &#123;</span><br><span class="line">      B[i] = A-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  A-&gt;limit = new_limit;</span><br><span class="line">  A-&gt;data = B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uba_add(uba* A, string x)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@ensures is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  A-&gt;data[A-&gt;size] = x;</span><br><span class="line">  (A-&gt;size)++;</span><br><span class="line"></span><br><span class="line">  if (A-&gt;size &lt; A-&gt;limit) return;</span><br><span class="line">  assert(A-&gt;limit &lt;= int_max() / 2); // Fail if array would get too big</span><br><span class="line">  uba_resize(A, A-&gt;limit * 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string uba_rem(uba* A)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">//@requires 0 &lt; uba_len(A);</span><br><span class="line">//@ensures is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  (A-&gt;size)--;</span><br><span class="line">  string x = A-&gt;data[A-&gt;size];</span><br><span class="line"></span><br><span class="line">  if (A-&gt;limit &gt;= 4 &amp;&amp; A-&gt;size &lt;= A-&gt;limit / 4)</span><br><span class="line">    uba_resize(A, A-&gt;limit / 2);</span><br><span class="line"></span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uba_print(uba* A)</span><br><span class="line">//@requires is_uba(A);</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;[&quot;);</span><br><span class="line">  for (int i = 0; i &lt; A-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;%s&quot;, A-&gt;data[i]);</span><br><span class="line">      if (i+1 != A-&gt;size) printf(&quot;, &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  printf(&quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Client type</span><br><span class="line">typedef uba* uba_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/******************************* Interface ******************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* uba_t;</span><br><span class="line"></span><br><span class="line">int uba_len(uba_t A)</span><br><span class="line">/*@requires A != NULL;   @*/</span><br><span class="line">/*@ensures \result &gt;= 0; @*/ ;</span><br><span class="line"></span><br><span class="line">uba_t uba_new(int size)</span><br><span class="line">/*@requires 0 &lt;= size;               @*/</span><br><span class="line">/*@ensures \result != NULL;          @*/</span><br><span class="line">/*@ensures uba_len(\result) == size; @*/ ;</span><br><span class="line"></span><br><span class="line">string uba_get(uba_t A, int i)</span><br><span class="line">/*@requires A != NULL;                @*/</span><br><span class="line">/*@requires 0 &lt;= i &amp;&amp; i &lt; uba_len(A); @*/ ;</span><br><span class="line"></span><br><span class="line">void uba_set(uba_t A, int i, string x)</span><br><span class="line">/*@requires A != NULL;                @*/</span><br><span class="line">/*@requires 0 &lt;= i &amp;&amp; i &lt; uba_len(A); @*/ ;</span><br><span class="line"></span><br><span class="line">void uba_add(uba_t A, string x)</span><br><span class="line">/*@requires A != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">string uba_rem(uba_t A)</span><br><span class="line">/*@requires A != NULL;      @*/</span><br><span class="line">/*@requires 0 &lt; uba_len(A); @*/ ;</span><br><span class="line"></span><br><span class="line">// bonus function</span><br><span class="line">void uba_print(uba_t A)</span><br><span class="line">/*@requires A != NULL;      @*/ ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="amortized-analysis">Amortized Analysis</h2>
<p>我们做Amortized Analysis的动机是估计不同函数/算法的runtime。之前的Worst-case analysis提供了runtime的上界。但其假定了每次对于函数的调用都有一样的runtime，并且有可能很大程度的夸张了资源耗费。Amortized Analysis将worst-case cost分配到整个操作序列上，使得其在分析一个操作序列中某一个操作序列的cost时很有用。 也用于分析那些在最坏情况下成本较高，但通过一系列操作可以摊销到较低平均成本的操作。例如，动态数组的扩容、链表的插入和删除等。</p>
<p>我们有两种进行Amortized Analysis的方法。<br>
一个比较方便的表示方法是使用token来表示操作的耗费（e.g. 1 token for push, 1 token for pop），在实际数据结构分析时判断每个操作本身所需的token和其隐含的token，这样就可以给每个操作得到固定的token值，再做平均。在对于多个操作组成的序列(e.g. push and pop from a stack)做分析时比较有用。</p>
<ol>
<li>Identify cost of future operations to save tokens for (e.g. resizing an array, moving elements over)</li>
<li>How many current operations do we perform before the future operation?(divide # of tokens to save by # of current ops that lead up to the future op)</li>
<li>Compute amortized cost(cost of operation itself + cost saved for future ops)</li>
</ol>
<p>另一种方法是计算一个序列的操作耗费然后除以操作次数，只有操作序列中只有一种操作时适用(e.g. uba_add)。</p>
<ol>
<li>Start having just finished an expensive operation.</li>
<li>Count # of operations until the next expensive operation.</li>
<li>Compute amortized cost (cost of sequence / # of ops in sequence)</li>
</ol>
<h1 id="hashing">Hashing</h1>
<ul>
<li><strong>哈希表</strong>：一种数据结构，通过哈希函数将键映射到表中的索引，解决键值对的存储和检索问题。</li>
<li><strong>哈希表操作</strong>：插入、查找、删除。</li>
</ul>
<p>不同的键可能映射到同一个索引，需要解决collision问题。</p>
<ul>
<li><strong>开放寻址法</strong>（Open Addressing）：在表中寻找下一个空闲位置。</li>
<li><strong>链地址法</strong>（Separate Chaining）：每个索引包含一个链表，所有映射到该索引的键值对都存储在这个链表中。</li>
</ul>
<p>如果所有桶（buckets）中的条目数量相同，则查找和插入操作的平均成本是 O(1)。如果所有条目都映射到同一个桶，则查找和插入操作的成本是 O(n)。通过适当调整哈希表的大小，可以保持插入操作的摊销成本为 O(1)。</p>
<p>哈希函数将键转换为哈希值的函数，理想的哈希函数应产生均匀分布的哈希值，减少碰撞。线性同余生成器（Linear Congruential Generator, LCG）是一种常见的伪随机数生成器，用于生成哈希值。</p>
<h2 id="generic-pointers">Generic Pointers</h2>
<p>传统的数据结构如栈（stacks）通常针对特定类型的元素设计，例如字符串或整数。为不同类型的元素创建栈需要复制和修改相同的代码，这导致代码重复且难以维护。</p>
<p>使用<code>elem</code>作为泛型类型名，让客户端代码定义<code>elem</code>的实际类型。客户端需要在客户端接口中定义<code>elem</code>的类型，例如<code>typedef string elem;</code>或<code>typedef int elem;</code>。</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>单一的库可以用于任何类型的栈。</li>
<li>如果需要不同类型的栈，只需在客户端适当地定义<code>elem</code>。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>客户端应用程序需要分割成两个文件，一个包含客户端定义，另一个包含其余的客户端应用程序代码。</li>
<li>强制使用不自然的编译模式，例如需要先编译库文件再编译客户端应用程序文件。</li>
<li>客户端应用程序最多只能包含一种类型的栈，因为<code>elem</code>的定义在整个应用程序中必须是一致的。</li>
</ul>
</li>
</ul>
<p>C1是C0语言的扩展，提供了泛型指针和函数指针，以增强泛型性。C1引入了<code>void*</code>指针类型，允许将任何类型的指针转换为<code>void*</code>，然后再转换回原始类型。</p>
<p>在栈的实现中，使用<code>void*</code>作为元素类型。将任何类型的元素转换为<code>void*</code>指针，以便在栈中存储和检索。C1语言在运行时会对<code>void*</code>指针进行检查，确保在转换回特定类型指针时类型匹配。如果错误地将<code>void*</code>转换为错误的类型，将导致运行时错误。</p>
<p>除了泛型指针，C1还提供了函数指针，允许将函数的地址作为值存储和传递。</p>
<h2 id="hash-dictionary">Hash Dictionary</h2>
<p>使用哈希表实现的字典，提供了快速的数据查找功能。字典中的每个条目包含一个键（key）和一个关联的数据（value）。</p>
<p>哈希表使用分链哈希表（separate-chaining hash table）实现，具有初始容量，可能支持自适应调整大小。</p>
<ul>
<li><strong>类型定义</strong>：<code>hdict_t</code> 用于操作字典，<code>key</code> 和 <code>entry</code> 为键和条目的类型。</li>
<li><strong>操作函数</strong>：
<ul>
<li><code>hdict_new(int capacity)</code>：创建新字典。</li>
<li><code>hdict_lookup(hdict_t D, key k)</code>：在字典中查找键。</li>
<li><code>hdict_insert(hdict_t D, entry e)</code>：向字典中插入条目。</li>
</ul>
</li>
</ul>
<p>客户端需要提供键的哈希值、键的比较函数等信息给库。客户端需要在接口中定义获取条目键、计算键的哈希值和比较两个键是否相同的函数。</p>
<p>哈希字典的每个链表节点包含数据和指向下一个节点的指针。字典头部包含字典的大小、容量和指向链表节点数组的指针。表示不变式确保字典的内部结构满足特定的条件，如链表无环、条目不为空等。</p>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">#use &lt;util&gt;</span><br><span class="line">#use &lt;conio&gt;</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/**************************** Client Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* entry;               // Supplied by client</span><br><span class="line">// typedef ______  key;                 // Supplied by client</span><br><span class="line"></span><br><span class="line">key  entry_key(entry x)                 // Supplied by client</span><br><span class="line">  /*@requires x != NULL; @*/ ;</span><br><span class="line">int  key_hash(key k);                   // Supplied by client</span><br><span class="line">bool key_equiv(key k1, key k2);         // Supplied by client</span><br><span class="line"></span><br><span class="line">/************************* End Client Interface *************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">typedef struct chain_node chain;</span><br><span class="line">struct chain_node &#123;</span><br><span class="line">  entry  data;           // != NULL; contains both key and value</span><br><span class="line">  chain* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct hdict_header hdict;</span><br><span class="line">struct hdict_header &#123;</span><br><span class="line">  int size;              // 0 &lt;= size</span><br><span class="line">  chain*[] table;        // \length(table) == capacity</span><br><span class="line">  int capacity;          // 0 &lt; capacity</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_array_expected_length(chain*[] table, int length) &#123;</span><br><span class="line">  //@assert \length(table) == length;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_hdict(hdict* H) &#123;</span><br><span class="line">  return H != NULL</span><br><span class="line">      &amp;&amp; H-&gt;capacity &gt; 0</span><br><span class="line">      &amp;&amp; H-&gt;size &gt;= 0</span><br><span class="line">      &amp;&amp; is_array_expected_length(H-&gt;table, H-&gt;capacity);</span><br><span class="line">   /* &amp;&amp; table contains correct number non-NULL entries in correct places */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int index_of_key(hdict* H, key k)</span><br><span class="line">//@requires is_hdict(H);</span><br><span class="line">//@ensures 0 &lt;= \result &amp;&amp; \result &lt; H-&gt;capacity;</span><br><span class="line">&#123;</span><br><span class="line">  return abs(key_hash(k) % H-&gt;capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hdict* hdict_new(int capacity)</span><br><span class="line">//@requires capacity &gt; 0;</span><br><span class="line">//@ensures is_hdict(\result);</span><br><span class="line">&#123;</span><br><span class="line">  hdict* H = alloc(hdict);</span><br><span class="line">  H-&gt;size = 0;</span><br><span class="line">  H-&gt;capacity = capacity;</span><br><span class="line">  H-&gt;table = alloc_array(chain*, capacity);</span><br><span class="line">  return H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry hdict_lookup(hdict* H, key k)</span><br><span class="line">//@requires is_hdict(H);</span><br><span class="line">//@ensures \result == NULL || key_equiv(entry_key(\result), k);</span><br><span class="line">&#123;</span><br><span class="line">  int i = index_of_key(H, k);</span><br><span class="line">  for (chain* p = H-&gt;table[i]; p != NULL; p = p-&gt;next) &#123;</span><br><span class="line">    if (key_equiv(entry_key(p-&gt;data), k))</span><br><span class="line">      return p-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hdict_insert(hdict* H, entry x)</span><br><span class="line">//@requires is_hdict(H);</span><br><span class="line">//@requires x != NULL;</span><br><span class="line">//@ensures is_hdict(H);</span><br><span class="line">//@ensures hdict_lookup(H, entry_key(x)) == x;</span><br><span class="line">&#123;</span><br><span class="line">  key k = entry_key(x);</span><br><span class="line">  int i = index_of_key(H, k);</span><br><span class="line">  for (chain* p = H-&gt;table[i]; p != NULL; p = p-&gt;next) &#123;</span><br><span class="line">    //@assert p-&gt;data != NULL;  // From preconditions -- operational reasoning!</span><br><span class="line">    if (key_equiv(entry_key(p-&gt;data), k)) &#123;</span><br><span class="line">      p-&gt;data = x;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // prepend new entry</span><br><span class="line">  chain* p = alloc(chain);</span><br><span class="line">  p-&gt;data = x;</span><br><span class="line">  p-&gt;next = H-&gt;table[i];</span><br><span class="line">  H-&gt;table[i] = p;</span><br><span class="line">  (H-&gt;size)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Statistics</span><br><span class="line">int chain_length(chain* p) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  while (p != NULL) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// report the distribution stats for the hashtable</span><br><span class="line">void hdict_stats(hdict* H)</span><br><span class="line">//@requires is_hdict(H);</span><br><span class="line">&#123;</span><br><span class="line">  int max = 0;</span><br><span class="line">  int[] A = alloc_array(int, 11);</span><br><span class="line">  for(int i = 0; i &lt; H-&gt;capacity; i++) &#123;</span><br><span class="line">    int j = chain_length(H-&gt;table[i]);</span><br><span class="line">    if (j &gt; 9) A[10]++;</span><br><span class="line">    else A[j]++;</span><br><span class="line">    if (j &gt; max) max = j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Hash table distribution: how many chains have size...\n&quot;);</span><br><span class="line">  for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    printf(&quot;...%d:   %d\n&quot;, i, A[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;...10+: %d\n&quot;, A[10]);</span><br><span class="line">  printf(&quot;Longest chain: %d\n&quot;, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client-side type</span><br><span class="line">typedef hdict* hdict_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/*************************** Library Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* hdict_t;</span><br><span class="line"></span><br><span class="line">hdict_t hdict_new(int capacity)</span><br><span class="line">/*@requires capacity &gt; 0; @*/</span><br><span class="line">/*@ensures \result != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">entry hdict_lookup(hdict_t H, key k)</span><br><span class="line">/*@requires H != NULL; @*/</span><br><span class="line">/*@ensures \result == NULL || key_equiv(entry_key(\result), k); @*/ ;</span><br><span class="line"></span><br><span class="line">void hdict_insert(hdict_t H, entry x)</span><br><span class="line">/*@requires H != NULL &amp;&amp; x != NULL; @*/</span><br><span class="line">/*@ensures hdict_lookup(H, entry_key(x)) == x; @*/ ;</span><br></pre></td></tr></table></figure>
<h2 id="generic-hash-dictionary">Generic Hash Dictionary</h2>
<p>泛型数据结构如哈希字典，其操作对数据类型是不可知的，可以用于任何类型的键和条目。泛型库允许客户端选择数据类型,可以在同一个应用程序中使用不同数据类型的多个实例。</p>
<p>哈希字典的泛型实现通过将键和条目类型定义为 <code>void*</code> 来实现泛型。客户端需要提供 <code>entry_key</code>, <code>key_hash</code>, 和 <code>key_equiv</code> 函数来处理键和条目的具体类型。客户端必须定义自己的 <code>entry</code> 和 <code>key</code> 类型，并提供相应的函数来满足库的接口。为了避免在客户端代码中重复定义相同的函数名，可以通过为客户端函数提供不同的名称（如 <code>key_hash_produce</code>）来解决。</p>
<p>通过将哈希字典库升级为使用 <code>void*</code> 类型，简化了客户端的使用，允许在同一个应用程序中使用不同的数据类型。哈希函数和等价函数需要和谐，即具有相同哈希值的键应该是等价的。</p>
<p>在这里需要提到Hash dictionary分为Generic Dictionaries和Half-Generic Dictionaries。其中Generic Dictionaries是整个字典都是泛型，也就是把key和entry都定义成void*，并且由client提供key_hash, entry_key和key_equiv函数。client提供的函数里面也要把void* cast成需要的指针类型后进行操作，最后把操作结束得到的指针cast回entry或者key类型。<br>
另一个Half-Generic的类型即指entry和key是有具体的类型的，而上述提到的函数也是library implementation中就已经有定义，client直接调用即可。<br>
上述两种情况中，Half-Generic适合使用在已经明确了任务需要处理的数据类型的情况，Generic适合更宽泛的Dictionary任务。</p>
<p>C0 语言的内存模型包括局部内存、分配内存、堆（heap）、栈（stack）、文本段（TEXT），数据段（DATA）和OS。 Heap等价于alloc memory(stores local variables and function call information)，Stack等价于local memory(stores data with a lifetime not tied to the function call stack, allocated and freed by the programmer)，Text(contains executable code of the program), Data(stores global and static variables that are initialized with a value or values that are not explicitly initialized), 和OS(system calls, interrupts and other OS-related function)。C1 语言扩展了 C0，允许使用函数指针，即可以存储和操作指向函数的指针。使用 <code>&amp;</code> 操作符获取函数的地址。将函数指针存储在变量或数据结构中。通过解引用函数指针来调用指向的函数。</p>
<p>函数类型的声明使用 <code>typedef</code> 为函数指针创建类型，如 <code>typedef int string_to_int_fn(string s);</code>。</p>
<p>函数指针是指针的一种，需要确保在使用前不为 NULL。C1 语言确保程序中的函数地址从不为 NULL，从而保证了函数指针的使用安全。函数指针允许动态调用函数，可以在运行时根据需要选择不同的函数来执行。</p>
<h1 id="binary-search-tree">Binary Search Tree</h1>
<p><strong>二叉搜索树</strong>是一种特殊的二叉树，其中每个节点的值都大于或等于其左子树中任何节点的值，并且小于或等于其右子树中任何节点的值。目标是开发一种数据结构，确保查找（lookup）、插入（insert）和查找最小元素（find_min）的最坏情况复杂度都是 O(log n)。</p>
<p>Quick Tree Facts:</p>
<ul>
<li>The empty tree is NULL</li>
<li>A leaf is a tree node with NULL left and right children</li>
<li>The height of a tree is the number of nodes in the longest path from the root to a leaf (inclusive)</li>
</ul>
<p><strong>哈希字典</strong>虽然平均情况下查找和插入操作的时间复杂度为 O(1)，但在最坏情况下可能会退化到 O(n)。<strong>二叉搜索树</strong>提供了一种保证最坏情况下时间复杂度为 O(log n) 的字典实现方式。</p>
<ul>
<li><strong>查找（Lookup）</strong>：利用二叉搜索树的结构，从根节点开始，根据键值比较，递归地在左子树或右子树中查找。</li>
<li><strong>插入（Insert）</strong>：与查找操作类似，找到正确的插入位置，然后将新元素插入到树中。</li>
<li><strong>查找最小元素（Find Min）</strong>：从根节点开始，一直沿着左子树向下查找，直到找到最小键值。</li>
<li><strong>节点结构</strong>：每个节点包含数据元素、指向左子树的指针和指向右子树的指针。</li>
<li><strong>递归性质</strong>：二叉搜索树可以被看作是空树，或者是由根节点和两个子树（左子树和右子树）组成的。</li>
<li><strong>Ordering invariant</strong>：For any <code>tree* T</code>, all entries in <code>T-&gt;left</code> must be less than <code>T-&gt;data</code>, and all entries in <code>T-&gt;right</code> must be greater than <code>T-&gt;data</code>.</li>
</ul>
<p>有序二叉树的最佳访问复杂度是O(log n)，最差复杂度是O(n)。在最佳case里面相当于进行二分查找，最差的case里面就是顺序查找一个链表。</p>
<ul>
<li><strong>is_bst</strong>：检查一个树是否是二叉搜索树。</li>
<li><strong>is_ordered</strong>：检查树中的节点是否满足二叉搜索树的顺序约束。</li>
</ul>
<h2 id="implementation">Implementation</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">/************************************************************************/</span><br><span class="line">/**************************** Client Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* entry;        // Supplied by client</span><br><span class="line">// typedef ______  key;          // Supplied by client</span><br><span class="line"></span><br><span class="line">key entry_key(entry e)           // Supplied by client</span><br><span class="line">/*@requires e != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">int key_compare(key k1, key k2); // Supplied by client</span><br><span class="line"></span><br><span class="line">/************************* End Client Interface *************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">/* BSTs and auxiliary functions */</span><br><span class="line">typedef struct tree_node tree;</span><br><span class="line">struct tree_node &#123;</span><br><span class="line">  tree* left;</span><br><span class="line">  entry data;  // != NULL</span><br><span class="line">  tree* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Minimal tree representation check */</span><br><span class="line">bool is_tree(tree* T) &#123; // minimal</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  return T-&gt;data != NULL</span><br><span class="line">      &amp;&amp; is_tree(T-&gt;left)</span><br><span class="line">      &amp;&amp; is_tree(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* is_ordered(T, lo, hi) checks if all entries in T</span><br><span class="line"> * are strictly in the interval (lo,hi).</span><br><span class="line"> * lo = NULL represents -infinity; hi = NULL represents +infinity */</span><br><span class="line">bool is_ordered(tree* T, entry lo, entry hi)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  //@assert T-&gt;data != NULL;   // because is_tree(T)</span><br><span class="line">  key k = entry_key(T-&gt;data);</span><br><span class="line">  return (lo == NULL || key_compare(entry_key(lo), k) &lt; 0)</span><br><span class="line">      &amp;&amp; (hi == NULL || key_compare(k, entry_key(hi)) &lt; 0)</span><br><span class="line">      &amp;&amp; is_ordered(T-&gt;left, lo, T-&gt;data)</span><br><span class="line">      &amp;&amp; is_ordered(T-&gt;right, T-&gt;data, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_bst(tree* T) &#123;</span><br><span class="line">  return is_tree(T)</span><br><span class="line">      &amp;&amp; is_ordered(T, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry bst_lookup(tree* T, key k)</span><br><span class="line">//@requires is_bst(T);</span><br><span class="line">//@ensures \result == NULL || key_compare(entry_key(\result), k) == 0;</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  int cmp = key_compare(k, entry_key(T-&gt;data));</span><br><span class="line">  if (cmp == 0)  return T-&gt;data;</span><br><span class="line">  if (cmp &lt;  0)  return bst_lookup(T-&gt;left, k);</span><br><span class="line">  //@assert cmp &gt; 0;</span><br><span class="line">  return bst_lookup(T-&gt;right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Builds a singleton tree with just entry e</span><br><span class="line">tree* leaf(entry e)</span><br><span class="line">//@requires e != NULL;</span><br><span class="line">//@ensures is_bst(\result);</span><br><span class="line">&#123;</span><br><span class="line">  tree* T = alloc(tree);</span><br><span class="line">  T-&gt;data = e;</span><br><span class="line">  T-&gt;left  = NULL;  // Not necessary</span><br><span class="line">  T-&gt;right = NULL;  // Not necessary</span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* bst_insert(tree* T, entry e)</span><br><span class="line">//@requires is_bst(T) &amp;&amp; e != NULL;</span><br><span class="line">//@ensures is_bst(\result) &amp;&amp; \result != NULL;</span><br><span class="line">//@ensures bst_lookup(\result, entry_key(e)) == e;</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return leaf(e);</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  int cmp = key_compare(entry_key(e), entry_key(T-&gt;data));</span><br><span class="line">  if (cmp == 0)     T-&gt;data = e;</span><br><span class="line">  else if (cmp &lt; 0) T-&gt;left = bst_insert(T-&gt;left, e);</span><br><span class="line">  else &#123; //@assert cmp &gt; 0;</span><br><span class="line">    T-&gt;right = bst_insert(T-&gt;right, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******* Implementing the dictionaries ******/</span><br><span class="line"></span><br><span class="line">struct dict_header &#123;</span><br><span class="line">  tree* root;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct dict_header dict;</span><br><span class="line"></span><br><span class="line">bool is_dict(dict* D) &#123;</span><br><span class="line">  return D != NULL &amp;&amp; is_bst(D-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dict* dict_new()</span><br><span class="line">//@ensures is_dict(\result);</span><br><span class="line">&#123;</span><br><span class="line">  dict* D = alloc(dict);</span><br><span class="line">  D-&gt;root = NULL;         // Not necessary</span><br><span class="line">  return D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry dict_lookup(dict* D, key k)</span><br><span class="line">//@requires is_dict(D);</span><br><span class="line">//@ensures \result == NULL || key_compare(entry_key(\result), k) == 0;</span><br><span class="line">&#123;</span><br><span class="line">  return bst_lookup(D-&gt;root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dict_insert(dict* D, entry e)</span><br><span class="line">//@requires is_dict(D) &amp;&amp; e != NULL;</span><br><span class="line">//@ensures is_dict(D) &amp;&amp; dict_lookup(D, entry_key(e)) == e;</span><br><span class="line">&#123;</span><br><span class="line">  D-&gt;root = bst_insert(D-&gt;root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry dict_min(dict* D)  // Return the smallest entry (or NULL)</span><br><span class="line">//@requires is_dict(D);</span><br><span class="line">&#123;</span><br><span class="line">  if (D-&gt;root == NULL) return NULL;</span><br><span class="line">  tree* T = D-&gt;root;</span><br><span class="line">  while (T-&gt;left != NULL)</span><br><span class="line">    T = T-&gt;left;</span><br><span class="line">  return T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef dict* dict_t;</span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/*************************** Library Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* dict_t;</span><br><span class="line"></span><br><span class="line">dict_t dict_new()</span><br><span class="line">/*@ensures \result != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">entry dict_lookup(dict_t D, key k)</span><br><span class="line">/*@requires D != NULL; @*/</span><br><span class="line">/*@ensures \result == NULL</span><br><span class="line">        || key_compare(entry_key(\result), k) == 0; @*/ ;</span><br><span class="line"></span><br><span class="line">void dict_insert(dict_t D, entry e)</span><br><span class="line">/*@requires D != NULL &amp;&amp; e != NULL; @*/</span><br><span class="line">/*@ensures dict_lookup(D, entry_key(e)) == e; @*/ ;</span><br><span class="line"></span><br><span class="line">entry dict_min(dict_t D)</span><br><span class="line">/*@requires D != NULL; @*/ ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="avl-tree">AVL Tree</h1>
<p>AVL 树是一种自平衡的二叉搜索树，保证了树的高度始终保持在 O(log n) 的范围内，其中 n 是树中节点的数量。目标是开发一种数据结构，确保查找（lookup）、插入（insert）和查找最小元素（find_min）的最坏情况复杂度都是 O(log n)。</p>
<p>在 AVL 树中，查找、插入和 find_min这些操作的最坏情况复杂度为 O(log n)。普通的二叉搜索树在某些情况下（如插入序列是有序的）可能会退化成链表，导致操作复杂度变为 O(n)。</p>
<p>平衡树的高度在 O(log n) 范围内。自平衡树在插入新节点后，树能够自动保持平衡。</p>
<p>AVL 树的每个节点的左子树和右子树的高度差不超过 1。节点的值满足二叉搜索树的顺序条件。</p>
<p>为了维护 AVL 树的平衡条件，可能需要进行单旋转或双旋转。当右子树的高度大于左子树的高度时进行左旋转。当左子树的高度大于右子树的高度时进行右旋转。双旋转即先进行一次右旋转，再进行一次左旋转，或先进行一次左旋转，再进行一次右旋转。</p>
<p>AVL 树的插入策略像在 BST 中一样插入新节点，修复任何高度不变性违规，从最低违规开始修复。在 AVL 树中插入一个节点，如果导致高度违规，则通过旋转修复，修复后的树高度保持不变或只增加 1。单旋转或双旋转都可以在 O(1) 的时间内完成，确保插入操作的整体复杂度为 O(log n)。</p>
<p>AVL 字典接口与 BST 字典接口相同，但内部实现使用 AVL 树。AVL 字典实现在 BST 实现的基础上进行修改，增加高度不变性的维护。AVL 树的表示不变性确保 AVL 树的每个节点都满足顺序不变性和高度不变性。</p>
<h3 id="implementation">Implementation</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line">/************************************************************************/</span><br><span class="line">/**************************** Client Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* entry;        // Supplied by client</span><br><span class="line">// typedef ______  key;          // Supplied by client</span><br><span class="line"></span><br><span class="line">key entry_key(entry e)           // Supplied by client</span><br><span class="line">/*@requires e != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">int key_compare(key k1, key k2); // Supplied by client</span><br><span class="line"></span><br><span class="line">/************************* End Client Interface *************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/************************* BEGIN IMPLEMENTATION *************************/</span><br><span class="line"></span><br><span class="line">/* BSTs and auxiliary functions */</span><br><span class="line">typedef struct tree_node tree;</span><br><span class="line">struct tree_node &#123;</span><br><span class="line">  tree* left;</span><br><span class="line">  entry data;  // != NULL</span><br><span class="line">  tree* right;</span><br><span class="line">  int height;  // &gt; 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Minimal tree representation check */</span><br><span class="line">bool is_tree(tree* T) &#123; // minimal</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  return T-&gt;data != NULL</span><br><span class="line">      &amp;&amp; is_tree(T-&gt;left)</span><br><span class="line">      &amp;&amp; is_tree(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* is_ordered(T, lo, hi) checks if all entries in T</span><br><span class="line"> * are strictly in the interval (lo,hi).</span><br><span class="line"> * lo = NULL represents -infinity; hi = NULL represents +infinity */</span><br><span class="line">bool is_ordered(tree* T, entry lo, entry hi)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  //@assert T-&gt;data != NULL;   // because is_tree(T)</span><br><span class="line">  key k = entry_key(T-&gt;data);</span><br><span class="line">  return (lo == NULL || key_compare(entry_key(lo), k) &lt; 0)</span><br><span class="line">      &amp;&amp; (hi == NULL || key_compare(k, entry_key(hi)) &lt; 0)</span><br><span class="line">      &amp;&amp; is_ordered(T-&gt;left, lo, T-&gt;data)</span><br><span class="line">      &amp;&amp; is_ordered(T-&gt;right, T-&gt;data, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* UNUSED: cost is O(n)</span><br><span class="line">int height(tree* T)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">//@ensures \result &gt;= 0;</span><br><span class="line">&#123;</span><br><span class="line">  if (T == NULL) return 0;</span><br><span class="line">  return 1 + max(height(T-&gt;left), height(T-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int height(tree* T) // O(1)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">//@ensures \result &gt;= 0;</span><br><span class="line">&#123;</span><br><span class="line">  return T == NULL ? 0 : T-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_specified_height(tree* T) &#123;</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line">  return is_specified_height(T-&gt;left)     // height(T-&gt;left)  is correct</span><br><span class="line">      &amp;&amp; is_specified_height(T-&gt;right)    // height(T-&gt;right) is correct</span><br><span class="line">      &amp;&amp; T-&gt;height == max(height(T-&gt;left),</span><br><span class="line">                          height(T-&gt;right)) + 1; // height(T) is correct</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_balanced(tree* T)</span><br><span class="line">//@requires is_tree(T);</span><br><span class="line">&#123;</span><br><span class="line">  if (T == NULL) return true;</span><br><span class="line">  return abs(height(T-&gt;left) - height(T-&gt;right)) &lt;= 1</span><br><span class="line">      &amp;&amp; is_balanced(T-&gt;left)</span><br><span class="line">      &amp;&amp; is_balanced(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool is_avl(tree* T) &#123;</span><br><span class="line">  return is_tree(T) &amp;&amp; is_ordered(T, NULL, NULL)</span><br><span class="line">      &amp;&amp; is_specified_height(T) &amp;&amp; is_balanced(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry avl_lookup(tree* T, key k)</span><br><span class="line">//@requires is_avl(T);</span><br><span class="line">//@ensures \result == NULL || key_compare(entry_key(\result), k) == 0;</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  int cmp = key_compare(k, entry_key(T-&gt;data));</span><br><span class="line">  if (cmp == 0)  return T-&gt;data;</span><br><span class="line">  if (cmp &lt;  0)  return avl_lookup(T-&gt;left, k);</span><br><span class="line">  //@assert cmp &gt; 0;</span><br><span class="line">  return avl_lookup(T-&gt;right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fix_height(tree* T)</span><br><span class="line">//@requires is_tree(T) &amp;&amp; T != NULL;</span><br><span class="line">//@requires is_specified_height(T-&gt;left);</span><br><span class="line">//@requires is_specified_height(T-&gt;right);</span><br><span class="line">//@ensures is_specified_height(T);</span><br><span class="line">&#123;</span><br><span class="line">  int hl = height(T-&gt;left);</span><br><span class="line">  int hr = height(T-&gt;right);</span><br><span class="line">  T-&gt;height = 1 + max(hl, hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* rotate_left(tree* T)</span><br><span class="line">//@requires T != NULL &amp;&amp; T-&gt;right != NULL;</span><br><span class="line">//@requires is_specified_height(T-&gt;left);</span><br><span class="line">//@requires is_specified_height(T-&gt;right);</span><br><span class="line">//@ensures is_specified_height(\result);</span><br><span class="line">&#123;</span><br><span class="line">  tree* temp = T-&gt;right;</span><br><span class="line">  T-&gt;right = T-&gt;right-&gt;left;</span><br><span class="line">  temp-&gt;left = T;</span><br><span class="line">  fix_height(T);</span><br><span class="line">  fix_height(temp);</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* rotate_right(tree* T)</span><br><span class="line">//@requires T != NULL &amp;&amp; T-&gt;left != NULL;</span><br><span class="line">//@requires is_specified_height(T-&gt;left);</span><br><span class="line">//@requires is_specified_height(T-&gt;right);</span><br><span class="line">//@ensures is_specified_height(\result);</span><br><span class="line">&#123;</span><br><span class="line">  tree* temp = T-&gt;left;</span><br><span class="line">  T-&gt;left = T-&gt;left-&gt;right;</span><br><span class="line">  temp-&gt;right = T;</span><br><span class="line">  fix_height(T);</span><br><span class="line">  fix_height(temp);</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* rebalance_right(tree* T)</span><br><span class="line">// T must be immediate result of a right-insertion</span><br><span class="line">//@requires T != NULL &amp;&amp; T-&gt;right != NULL;</span><br><span class="line">//@requires is_avl(T-&gt;left) &amp;&amp; is_avl(T-&gt;right);</span><br><span class="line">//@ensures is_avl(\result);</span><br><span class="line">&#123;</span><br><span class="line">  if (height(T-&gt;right) - height(T-&gt;left) == 2) &#123;   // violation!</span><br><span class="line">    if (height(T-&gt;right-&gt;right) &gt; height(T-&gt;right-&gt;left)) &#123;</span><br><span class="line">      // Single rotation</span><br><span class="line">      T = rotate_left(T);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //@assert height(T-&gt;right-&gt;left) &gt; height(T-&gt;right-&gt;right);</span><br><span class="line">      // Double rotation</span><br><span class="line">      T-&gt;right = rotate_right(T-&gt;right);</span><br><span class="line">      T = rotate_left(T);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123; // No rotation needed, but tree may have grown</span><br><span class="line">    fix_height(T);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* rebalance_left(tree* T)</span><br><span class="line">// T must be immediate result of a left-insertion</span><br><span class="line">//@requires T != NULL &amp;&amp; T-&gt;left != NULL;</span><br><span class="line">//@requires is_avl(T-&gt;left) &amp;&amp; is_avl(T-&gt;right);</span><br><span class="line">//@ensures is_avl(\result);</span><br><span class="line">&#123;</span><br><span class="line">  if (height(T-&gt;left) - height(T-&gt;right) == 2) &#123;   // violation!</span><br><span class="line">    if (height(T-&gt;left-&gt;left) &gt; height(T-&gt;left-&gt;right)) &#123;</span><br><span class="line">      // Single rotation</span><br><span class="line">      T = rotate_right(T);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //@assert height(T-&gt;left-&gt;right) &gt; height(T-&gt;left-&gt;left);</span><br><span class="line">      // Double rotation</span><br><span class="line">      T-&gt;left = rotate_left(T-&gt;left);</span><br><span class="line">      T = rotate_right(T);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123; // No rotation needed, but tree may have grown</span><br><span class="line">    fix_height(T);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Builds a singleton tree with just entry e</span><br><span class="line">tree* leaf(entry e)</span><br><span class="line">//@requires e != NULL;</span><br><span class="line">//@ensures is_avl(\result);</span><br><span class="line">&#123;</span><br><span class="line">  tree* T = alloc(tree);</span><br><span class="line">  T-&gt;data = e;</span><br><span class="line">  T-&gt;left  = NULL;  // Not necessary</span><br><span class="line">  T-&gt;right = NULL;  // Not necessary</span><br><span class="line">  T-&gt;height = 1;</span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* avl_insert(tree* T, entry e)</span><br><span class="line">//@requires is_avl(T) &amp;&amp; e != NULL;</span><br><span class="line">//@ensures is_avl(\result) &amp;&amp; \result != NULL;</span><br><span class="line">//@ensures avl_lookup(\result, entry_key(e)) == e;</span><br><span class="line">&#123;</span><br><span class="line">  // Code for empty tree</span><br><span class="line">  if (T == NULL) return leaf(e);</span><br><span class="line"></span><br><span class="line">  // Code for non-empty tree</span><br><span class="line">  //@assert is_avl(T-&gt;left);</span><br><span class="line">  //@assert is_avl(T-&gt;right);</span><br><span class="line">  int cmp = key_compare(entry_key(e), entry_key(T-&gt;data));</span><br><span class="line">  if (cmp == 0)</span><br><span class="line">    T-&gt;data = e;</span><br><span class="line">  else if (cmp &lt; 0) &#123;  // Go left</span><br><span class="line">    T-&gt;left = avl_insert(T-&gt;left, e);</span><br><span class="line">    //@assert is_avl(T-&gt;left) &amp;&amp; T-&gt;left != NULL &amp;&amp; is_avl(T-&gt;right);</span><br><span class="line">    T = rebalance_left(T);</span><br><span class="line">    //@assert is_avl(T);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;               // Go right</span><br><span class="line">    //@assert cmp &gt; 0;</span><br><span class="line">    T-&gt;right = avl_insert(T-&gt;right, e);</span><br><span class="line">    //@assert is_avl(T-&gt;left) &amp;&amp; is_avl(T-&gt;right) &amp;&amp; T-&gt;right != NULL;</span><br><span class="line">    T = rebalance_right(T);</span><br><span class="line">    //@assert is_avl(T);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******* Implementing the dictionaries ******/</span><br><span class="line"></span><br><span class="line">struct dict_header &#123;</span><br><span class="line">  tree* root;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct dict_header dict;</span><br><span class="line"></span><br><span class="line">bool is_dict(dict* D) &#123;</span><br><span class="line">  return D != NULL &amp;&amp; is_avl(D-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dict* dict_new()</span><br><span class="line">//@ensures is_dict(\result);</span><br><span class="line">&#123;</span><br><span class="line">  dict* D = alloc(dict);</span><br><span class="line">  D-&gt;root = NULL;         // Not necessary</span><br><span class="line">  return D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry dict_lookup(dict* D, key k)</span><br><span class="line">//@requires is_dict(D);</span><br><span class="line">//@ensures \result == NULL || key_compare(entry_key(\result), k) == 0;</span><br><span class="line">&#123;</span><br><span class="line">  return avl_lookup(D-&gt;root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dict_insert(dict* D, entry e)</span><br><span class="line">//@requires is_dict(D) &amp;&amp; e != NULL;</span><br><span class="line">//@ensures is_dict(D);</span><br><span class="line">//@ensures dict_lookup(D, entry_key(e)) == e;</span><br><span class="line">&#123;</span><br><span class="line">  D-&gt;root = avl_insert(D-&gt;root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry dict_min(dict* D)  // Return the smallest entry (or NULL)</span><br><span class="line">//@requires is_dict(D);</span><br><span class="line">&#123;</span><br><span class="line">  if (D-&gt;root == NULL) return NULL;</span><br><span class="line">  tree* T = D-&gt;root;</span><br><span class="line">  while (T-&gt;left != NULL)</span><br><span class="line">    T = T-&gt;left;</span><br><span class="line">  return T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef dict* dict_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************** END IMPLEMENTATION **************************/</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line">/*************************** Library Interface **************************/</span><br><span class="line"></span><br><span class="line">// typedef ______* dict_t;</span><br><span class="line"></span><br><span class="line">dict_t dict_new()</span><br><span class="line">/*@ensures \result != NULL; @*/ ;</span><br><span class="line"></span><br><span class="line">entry dict_lookup(dict_t D, key k)</span><br><span class="line">/*@requires D != NULL; @*/</span><br><span class="line">/*@ensures \result == NULL</span><br><span class="line">        || key_compare(entry_key(\result), k) == 0; @*/ ;</span><br><span class="line"></span><br><span class="line">void dict_insert(dict_t D, entry e)</span><br><span class="line">/*@requires D != NULL &amp;&amp; e != NULL; @*/</span><br><span class="line">/*@ensures dict_lookup(D, entry_key(e)) == e; @*/ ;</span><br><span class="line"></span><br><span class="line">entry dict_min(dict_t D)</span><br><span class="line">/*@requires D != NULL; @*/ ;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article><aside class="toc"><h3>Table of contents</h3><nav id="toc"></nav></aside></main><footer class="site-footer"><div class="container"><p>© 2025 Zhang Shoufeng</p></div></footer><script src="/js/minimalfolio.js"></script><script>(function(){
  const content = document.querySelector('.post-content');
  const toc = document.getElementById('toc');
  if(!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  const ul = document.createElement('ul');
  headings.forEach(function(h){
    const id = h.id || h.textContent.trim().toLowerCase().replace(/[^a-z0-9\s]/g,'').replace(/\s+/g,'-');
    h.id = id;
    const li = document.createElement('li');
    li.className = h.tagName.toLowerCase();
    const a = document.createElement('a');
    a.href = '#' + id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  toc.appendChild(ul);
})();</script></body></html>